

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>bio_rtd.core &mdash; bio_rtd  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../content.html" class="icon icon-home"> bio_rtd
          

          
          </a>

          
            
            
              <div class="version">
                0.7.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../index.html">Home</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../user_guide.html">User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API Reference</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../content.html">bio_rtd</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../content.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>bio_rtd.core</li>
    
    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for bio_rtd.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Module with abstract classes.&quot;&quot;&quot;</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Inlet&#39;</span><span class="p">,</span> <span class="s1">&#39;UnitOperation&#39;</span><span class="p">,</span>
           <span class="s1">&#39;RtdModel&#39;</span><span class="p">,</span> <span class="s1">&#39;UserInterface&#39;</span><span class="p">,</span>
           <span class="s1">&#39;PDF&#39;</span><span class="p">,</span> <span class="s1">&#39;ChromatographyLoadBreakthrough&#39;</span><span class="p">,</span>
           <span class="s1">&#39;ParameterSetList&#39;</span><span class="p">]</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;0.7.1&#39;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Jure Sencar&#39;</span>

<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">_typing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span> <span class="k">as</span> <span class="n">_ABC</span><span class="p">,</span> <span class="n">abstractmethod</span> <span class="k">as</span> <span class="n">_abstractmethod</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="n">_OrderedDict</span>

<span class="kn">from</span> <span class="nn">bio_rtd</span> <span class="kn">import</span> <span class="n">logger</span> <span class="k">as</span> <span class="n">_logger</span>
<span class="kn">from</span> <span class="nn">bio_rtd</span> <span class="kn">import</span> <span class="n">adj_par</span> <span class="k">as</span> <span class="n">_adj_par</span>
<span class="kn">from</span> <span class="nn">bio_rtd</span> <span class="kn">import</span> <span class="n">utils</span> <span class="k">as</span> <span class="n">_utils</span>


<div class="viewcode-block" id="DefaultLoggerLogic"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.DefaultLoggerLogic">[docs]</a><span class="k">class</span> <span class="nc">DefaultLoggerLogic</span><span class="p">(</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="c1"># noinspection PyProtectedMember</span>
    <span class="sd">&quot;&quot;&quot;Default binding of the `RtdLogger` to a class.</span>

<span class="sd">    The class holds a reference to a :class:`bio_rtd.logger.RtdLogger`</span>
<span class="sd">    instance. When the class receives the instance, it plants a data</span>
<span class="sd">    tree into it. If the class is asked to provide the instance before</span>
<span class="sd">    it received one, then an instance of</span>
<span class="sd">    :class:`bio_rtd.logger.DefaultLogger` is created and passed on.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    logger_parent_id</span>
<span class="sd">        Custom unique id that belongs to the instance of the class.</span>

<span class="sd">        The data tree of this instance is stored in</span>
<span class="sd">        :class:`bio_rtd.logger.RtdLogger` under the `logger_parent_id`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; logger_parent_id = &quot;parent_unit_operation&quot;</span>
<span class="sd">    &gt;&gt;&gt; l = DefaultLoggerLogic(logger_parent_id)</span>
<span class="sd">    &gt;&gt;&gt; isinstance(l.log, _logger.DefaultLogger)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; # Log error: DefaultLogger raises RuntimeError.</span>
<span class="sd">    &gt;&gt;&gt; l.log.e(&quot;Error Description&quot;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    RuntimeError: Error Description</span>
<span class="sd">    &gt;&gt;&gt; # Log waring: DefaultLogger prints it.</span>
<span class="sd">    &gt;&gt;&gt; l.log.w(&quot;Warning Description&quot;)</span>
<span class="sd">    Warning Description</span>
<span class="sd">    &gt;&gt;&gt; # Log info: DefaultLogger ignores it.</span>
<span class="sd">    &gt;&gt;&gt; l.log.i(&quot;Info&quot;)</span>
<span class="sd">    &gt;&gt;&gt; l.log.log_data = True</span>
<span class="sd">    &gt;&gt;&gt; l.log.log_level = _logger.RtdLogger.DEBUG</span>
<span class="sd">    &gt;&gt;&gt; l.log.i_data(l._log_tree, &quot;a&quot;, 3)  # store value in logger</span>
<span class="sd">    &gt;&gt;&gt; l.log.d_data(l._log_tree, &quot;b&quot;, 7)  # store at DEBUG level</span>
<span class="sd">    &gt;&gt;&gt; l.log.get_data_tree(logger_parent_id)[&quot;b&quot;]</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; l.log = _logger.StrictLogger()</span>
<span class="sd">    &gt;&gt;&gt; # Log waring: StrictLogger raises RuntimeError.</span>
<span class="sd">    &gt;&gt;&gt; l.log.w(&quot;Warning Info&quot;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    RuntimeError: Warning Info</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`bio_rtd.logger.DefaultLogger`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger_parent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_instance_id</span> <span class="o">=</span> <span class="n">logger_parent_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_entity_id</span> <span class="o">=</span> <span class="n">logger_parent_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>  <span class="c1"># place to store logged data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Reference of the `RtdLogger` instance.</span>

<span class="sd">        Setter also plants instance data tree into passed logger.</span>

<span class="sd">        If logger is requested, but not yet set, then a</span>
<span class="sd">        :class:`bio_rtd.logger.DefaultLogger` is instantiated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">_logger</span><span class="o">.</span><span class="n">DefaultLogger</span><span class="p">()</span>  <span class="c1"># init default logger</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>

    <span class="nd">@log</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">set_data_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_entity_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">)</span>

<div class="viewcode-block" id="DefaultLoggerLogic.set_logger_from_parent"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.DefaultLoggerLogic.set_logger_from_parent">[docs]</a>    <span class="k">def</span> <span class="nf">set_logger_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                               <span class="n">logger</span><span class="p">:</span> <span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inherit logger from parent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent_id</span>
<span class="sd">            Unique identifier of parent instance.</span>
<span class="sd">        logger</span>
<span class="sd">            Logger from parent instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_entity_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">parent_id</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_instance_id</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">set_data_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_entity_id</span><span class="p">,</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Inlet"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.Inlet">[docs]</a><span class="k">class</span> <span class="nc">Inlet</span><span class="p">(</span><span class="n">DefaultLoggerLogic</span><span class="p">,</span> <span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generates starting flow rate and concentration profiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">        Starts with 0 and has a constant time step.</span>
<span class="sd">    species_list</span>
<span class="sd">        List with names of simulating process fluid species.</span>
<span class="sd">    inlet_id</span>
<span class="sd">        Unique identifier of an instance. It is stored in :attr:`uo_id`.</span>
<span class="sd">    gui_title</span>
<span class="sd">        Readable title of an instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">species_list</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">inlet_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">inlet_id</span><span class="p">)</span>  <span class="c1"># logger</span>
        
        <span class="c1"># Assert proper time vector.</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;t should start with 0&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;t should be a 1D np.ndarray&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.001</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">/</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> \
            <span class="s2">&quot;t should have a fixed step size&quot;</span>
        
        <span class="c1"># Species</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species_list</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">species_list</span>
        <span class="sd">&quot;&quot;&quot;List with names of simulating process fluid species.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">species_list</span><span class="p">)</span>
        
        <span class="c1"># Strings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">inlet_id</span>
        <span class="sd">&quot;&quot;&quot;Unique identifier of the instance.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">gui_title</span>
        <span class="sd">&quot;&quot;&quot;Human readable title (for plots).&quot;&quot;&quot;</span>
        
        <span class="c1"># Placeholders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_par_list</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_adj_par</span><span class="o">.</span><span class="n">AdjustableParameter</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="sd">&quot;&quot;&quot;List of adjustable parameters exposed to the GUI.&quot;&quot;&quot;</span>
        
        <span class="c1"># Outputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_out</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>

<div class="viewcode-block" id="Inlet.get_t"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.Inlet.get_t">[docs]</a>    <span class="k">def</span> <span class="nf">get_t</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get simulation time vector.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span></div>

<div class="viewcode-block" id="Inlet.get_n_species"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.Inlet.get_n_species">[docs]</a>    <span class="k">def</span> <span class="nf">get_n_species</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get number of process fluid species.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span></div>

<div class="viewcode-block" id="Inlet.refresh"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.Inlet.refresh">[docs]</a>    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Updates output profiles.</span>

<span class="sd">        Internally it updates `self._f_out` and `self._c_out` based on</span>
<span class="sd">        instance attribute values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Inlet.get_result"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.Inlet.get_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get flow rate and concentration profiles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f_out</span>
<span class="sd">            Flow rate profile.</span>
<span class="sd">        c_out</span>
<span class="sd">            Concentration profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_out</span></div></div>


<div class="viewcode-block" id="UnitOperation"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.UnitOperation">[docs]</a><span class="k">class</span> <span class="nc">UnitOperation</span><span class="p">(</span><span class="n">DefaultLoggerLogic</span><span class="p">,</span> <span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Processes flow rate and concentration profiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">        Starts with 0 and has a constant time step.</span>
<span class="sd">    uo_id</span>
<span class="sd">        Unique identifier.</span>
<span class="sd">    gui_title</span>
<span class="sd">        Readable title for GUI.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">uo_id</span><span class="p">)</span>  <span class="c1"># logger</span>
        <span class="c1"># simulation time vector</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Time vector must start with 0&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># time step</span>
        <span class="c1"># id and title</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">uo_id</span>
        <span class="sd">&quot;&quot;&quot;Unique identifier of the instance&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">gui_title</span>
        <span class="sd">&quot;&quot;&quot;Readable title for GUI&quot;&quot;&quot;</span>

        <span class="c1"># adjustable parameter list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adj_par_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;list of :class:`bio_rtd.adj_par.AdjustableParameter`: List</span>
<span class="sd">        of adjustable parameters exposed to the GUI.&quot;&quot;&quot;</span>
        <span class="c1"># hide unit operation from plots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gui_hidden</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Hide the of the unit operation (default False).&quot;&quot;&quot;</span>

        <span class="c1"># start-up phase (optional initial delay)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_until_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Discard inlet until given time.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_until_min_c</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="sd">&quot;&quot;&quot;Discard inlet until given concentration is reached.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_until_min_c_rel</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="sd">&quot;&quot;&quot;Discard inlet until given concentration relative to is reached.</span>
<span class="sd">        </span>
<span class="sd">        Specified concentration is relative to the max concentration.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_n_cycles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Discard first n cycles of the periodic inlet flow rate profile.&quot;&quot;&quot;</span>
        <span class="c1"># shout-down phase (optional early stop)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_until_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Discard outlet until given time.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_until_min_c</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="sd">&quot;&quot;&quot;Discard outlet until given concentration is reached.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_until_min_c_rel</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="sd">&quot;&quot;&quot;Discard outlet until given concentration relative to is reached.</span>
<span class="sd">        </span>
<span class="sd">        Specified concentration is relative to the max concentration.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_n_cycles</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Discard first n cycles of the periodic outlet flow rate profile.&quot;&quot;&quot;</span>

        <span class="c1"># placeholders, populated during simulation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c1"># concentration profiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>  <span class="c1"># flow rate profile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># number of species</span>

    <span class="k">def</span> <span class="nf">_assert_valid_species_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">species</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Species indexes start with 0.</span>

<span class="sd">        List must be ordered in ascending order (to prevent bugs).</span>
<span class="sd">        List must have unique values (again, to prevent bugs).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">species</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="s2">&quot;Species list is empty&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="n">species</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> \
                <span class="s2">&quot;Index of species should be less than number of species&quot;</span>
            <span class="k">assert</span> <span class="nb">min</span><span class="p">(</span><span class="n">species</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> \
                <span class="s2">&quot;Index of species should not be negative&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">species</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> \
                <span class="s2">&quot;Vector with species should not have duplicate values&quot;</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">species</span><span class="p">))</span> <span class="o">==</span> <span class="n">species</span><span class="p">,</span> \
                <span class="s2">&quot;Values in vector with species must be ascending&quot;</span>

    <span class="k">def</span> <span class="nf">_is_flow_box_shaped</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Constant profile with optional leading or trailing zeros.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;Flow rate is negative!!!&quot;</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="s2">&quot;Flow rate is 0!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">max_flow_start</span><span class="p">,</span> <span class="n">max_flow_end</span> <span class="o">=</span> \
            <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start_and_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:</span><span class="n">max_flow_start</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">max_flow_end</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">max_flow_start</span><span class="p">:</span><span class="n">max_flow_end</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_i_flow_on</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Detect when the flow rate switches from off to on.</span>

<span class="sd">        In case of periodic flow rate, the function returns all</span>
<span class="sd">        switching events.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        i_interval_start</span>
<span class="sd">            Indexes of time points at which the flow rate turns on.</span>
<span class="sd">            Each index corresponds to a leading non-zero value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="s2">&quot;Flow rate is 0!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">()),</span> \
            <span class="s2">&quot;flow rate must have a constant &#39;on&#39; value&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_assert_periodic_flow</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                                                     <span class="nb">float</span><span class="p">,</span>
                                                     <span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Assert and provides info about periodic flow rate.</span>

<span class="sd">        Only last period is allowed to be shorter than others.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        i_flow_start_list</span>
<span class="sd">            Indexes of time-points at which the flow rate gets turned on</span>
<span class="sd">        i_flow_on_average</span>
<span class="sd">            Number of time-points of flow &#39;on&#39; interval.</span>
<span class="sd">        t_cycle_duration</span>
<span class="sd">            Duration of average cycle (&#39;on&#39; + &#39;off&#39; interval)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get all flow on positions.</span>
        <span class="n">i_flow_start_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_i_flow_on</span><span class="p">()</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Flow is 0&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> \
            <span class="s2">&quot;Periodic flow must have at least 2 cycles&quot;</span>

        <span class="c1"># Get average cycle duration.</span>
        <span class="n">t_cycle_duration</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">_np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">)</span> <span class="o">-</span> <span class="n">t_cycle_duration</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;Periodic flow rate must have fixed cycle duration&quot;</span>

        <span class="c1"># Assert periods.</span>
        <span class="n">i_flow_on_first</span> <span class="o">=</span> \
            <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">i_flow_start_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">i_flow_on_total</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">n_cycles</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">on_mask</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">)):</span>
            <span class="c1"># Get next stop.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">):</span>
                <span class="n">i_cycle_flow_on_duration</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_end</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">i_flow_start_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_cycle_flow_on_duration</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">i_flow_start_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="p">)</span>
                <span class="n">i_flow_on_total</span> <span class="o">+=</span> <span class="n">i_cycle_flow_on_duration</span>
                <span class="n">n_cycles</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i_flow_off</span> <span class="o">=</span> <span class="n">i_flow_start_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_cycle_flow_on_duration</span>
            <span class="n">on_mask</span><span class="p">[</span><span class="n">i_flow_start_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">i_flow_off</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_flow_start_list</span><span class="p">):</span>
                <span class="c1"># allow last cycle to be clipped</span>
                <span class="k">assert</span> <span class="n">i_cycle_flow_on_duration</span> <span class="o">-</span> <span class="n">i_flow_on_first</span> <span class="o">&lt;=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># allow to be 1 time step off the first cycle</span>
                <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i_cycle_flow_on_duration</span> <span class="o">-</span> <span class="n">i_flow_on_first</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>
        <span class="c1"># Flow can be either off or on at the constant value.</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">on_mask</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="o">~</span><span class="n">on_mask</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">i_flow_on_average</span> <span class="o">=</span> <span class="n">i_flow_on_total</span> <span class="o">/</span> <span class="n">n_cycles</span>

        <span class="k">return</span> <span class="n">i_flow_start_list</span><span class="p">,</span> <span class="n">i_flow_on_average</span><span class="p">,</span> <span class="n">t_cycle_duration</span>

    <span class="k">def</span> <span class="nf">_estimate_steady_state_mean_f</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimate mean flow rate in a period of periodic flow rate.</span>

<span class="sd">        Uses `self._assert_periodic_flow()` to get data about flow rate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (float, float)</span>
<span class="sd">            f_mean</span>
<span class="sd">                Mean flow rate in one cycle.</span>
<span class="sd">            t_cycle_duration</span>
<span class="sd">                Duration of a cycle (&#39;on&#39; + &#39;off&#39; interval).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">i_flow_on_d</span><span class="p">,</span> <span class="n">t_cycle_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_periodic_flow</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i_flow_on_d</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Flow is turned on for </span><span class="si">{</span><span class="n">i_flow_on_d</span><span class="si">}</span><span class="s2"> (&lt; 6) time points&quot;</span><span class="p">)</span>
        <span class="n">f_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="n">i_flow_on_d</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">/</span> <span class="n">t_cycle_duration</span>
        <span class="k">return</span> <span class="n">f_mean</span><span class="p">,</span> <span class="n">t_cycle_duration</span>

    <span class="k">def</span> <span class="nf">_estimate_steady_state_mean_c</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">species</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Estimate mean concentration after start-up phase.</span>

<span class="sd">        In case of box shaped flow rate, the steady-state concentration</span>
<span class="sd">        is estimated as an average concentration between the first and</span>
<span class="sd">        the last crossing of 90 % of the max concentration of the sum</span>
<span class="sd">        across relevant species.</span>

<span class="sd">        In case of periodic flow rate, the steady-state concentration</span>
<span class="sd">        is estimated as an average concentration during the cycle with</span>
<span class="sd">        the largest average concentration.</span>

<span class="sd">        If possible, define the model so that this function is not</span>
<span class="sd">        needed; estimates can in general lead to unintuitive results.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        species</span>
<span class="sd">            List of indexes of relevant species. (indexes start with 0).</span>
<span class="sd">            If not specified, all species are selected.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_mean_ss: ndarray</span>
<span class="sd">            Estimated steady-state mean concentration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">species</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">species</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_assert_valid_species_list</span><span class="p">(</span><span class="n">species</span><span class="p">)</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[</span><span class="n">species</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="s2">&quot;Concentration is zero for all relevant components&quot;</span><span class="p">)</span>
            <span class="n">load_c_ss</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;load_c_ss&#39;</span><span class="p">,</span> <span class="n">load_c_ss</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">load_c_ss</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_flow_box_shaped</span><span class="p">():</span>
            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[</span><span class="n">species</span><span class="p">][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">i_st</span><span class="p">,</span> <span class="n">i_end</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start_and_end</span><span class="p">(</span>
                <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.9</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Steady-state concentration is being estimated&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; as an average concentration withing 90 %&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; between the first and the last crossing of 90 %&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; of the max concentration for sum across&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; species: </span><span class="si">{</span><span class="n">species</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">load_c_ss</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">c</span><span class="p">[:,</span> <span class="n">i_st</span><span class="p">:</span><span class="n">i_end</span><span class="p">],</span> <span class="mi">1</span><span class="p">)[:,</span> <span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;load_c_ss&#39;</span><span class="p">,</span> <span class="n">load_c_ss</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">load_c_ss</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get info about periodic flow rate.</span>
            <span class="n">i_flow_on_start_list</span><span class="p">,</span> <span class="n">i_flow_on_duration</span><span class="p">,</span> <span class="n">t_cycle_duration</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_assert_periodic_flow</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Steady-state concentration is being estimated&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; as an average concentration in the cycle&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; with the largest average concentration&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; summed across species: </span><span class="si">{</span><span class="n">species</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">m_max</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">c_max</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">species</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_st</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">i_flow_on_start_list</span><span class="p">):</span>
                <span class="n">i_flow_on_duration_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">i_flow_on_duration</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">i_st</span> <span class="o">+</span> <span class="n">i_flow_on_duration_int</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">_c_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[</span><span class="n">species</span><span class="p">,</span> <span class="n">i_st</span><span class="p">:</span><span class="n">i_st</span> <span class="o">+</span> <span class="n">i_flow_on_duration_int</span><span class="p">]</span> \
                    <span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_c_max</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">m_max</span><span class="p">:</span>
                    <span class="n">c_max</span> <span class="o">=</span> <span class="n">_c_max</span>
                    <span class="n">m_max</span> <span class="o">=</span> <span class="n">_c_max</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># Add dimension: (n_species,) -&gt; (n_species, 1)</span>
            <span class="n">load_c_ss</span> <span class="o">=</span> <span class="n">c_max</span><span class="p">[:,</span> <span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;load_c_ss&#39;</span><span class="p">,</span> <span class="n">load_c_ss</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">load_c_ss</span>

    <span class="k">def</span> <span class="nf">_ensure_single_non_negative_parameter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">log_level_multiple</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                              <span class="n">log_level_none</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check if one or multiple parameters are non-negative.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        log_level_multiple</span>
<span class="sd">            Log level at which the function reports to `RtdLogger` in</span>
<span class="sd">            case of multiple non-negative parameters.</span>
<span class="sd">        log_level_none</span>
<span class="sd">            Log level at which the function reports to `RtdLogger` in</span>
<span class="sd">            case of no non-negative parameters.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">non_null_keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_null_keys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">log_level_multiple</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;Only one of the parameters: </span><span class="si">{</span><span class="n">non_null_keys</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; should be defined!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_null_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span>
                <span class="n">log_level_none</span><span class="p">,</span>
                <span class="sa">f</span><span class="s2">&quot;One of the parameters: </span><span class="si">{</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2"> should be defined!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cut_start_of_c_and_f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outlet</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Trim beginning of flow rate and concentration profiles</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outlet</span>
<span class="sd">            Current profiles have already been processed by this</span>
<span class="sd">            `UnitOperation`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="s2">&quot;Flow rate is 0!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">*=</span> <span class="mi">0</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">outlet</span><span class="p">:</span>
            <span class="n">discard_until_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_until_t</span>
            <span class="n">discard_n_cycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_n_cycles</span>
            <span class="n">discard_until_min_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_until_min_c</span>
            <span class="n">discard_until_min_c_rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_outlet_until_min_c_rel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">discard_until_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_until_t</span>
            <span class="n">discard_n_cycles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_n_cycles</span>
            <span class="n">discard_until_min_c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_until_min_c</span>
            <span class="n">discard_until_min_c_rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discard_inlet_until_min_c_rel</span>

        <span class="k">def</span> <span class="nf">get_cycle_start</span><span class="p">(</span><span class="n">_i</span><span class="p">,</span> <span class="n">_i_start_list</span><span class="p">,</span> <span class="n">_i_duration</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">_i_start</span> <span class="ow">in</span> <span class="n">_i_start_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_i</span> <span class="o">&lt;=</span> <span class="n">_i_start</span> <span class="o">+</span> <span class="n">_i_duration</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_i_start</span>

        <span class="n">i_init_cut</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">_aux_has_min_c</span> <span class="o">=</span> <span class="n">discard_until_min_c</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> \
            <span class="ow">and</span> <span class="n">discard_until_min_c</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">_aux_has_min_c_rel</span> <span class="o">=</span> <span class="n">discard_until_min_c_rel</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> \
            <span class="ow">and</span> <span class="n">discard_until_min_c_rel</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">_aux_has_min_c</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">discard_until_min_c</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span>
            <span class="n">discard_until_min_c</span> <span class="o">=</span> \
                <span class="n">discard_until_min_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_aux_has_min_c_rel</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">discard_until_min_c_rel</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span>
            <span class="n">discard_until_min_c_rel</span> <span class="o">=</span> \
                <span class="n">discard_until_min_c_rel</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_single_non_negative_parameter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">discard_until_t</span><span class="o">=</span><span class="n">discard_until_t</span><span class="p">,</span>
            <span class="n">discard_until_min_c</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">_aux_has_min_c</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">discard_until_min_c_rel</span><span class="o">=</span><span class="mi">1</span> <span class="k">if</span> <span class="n">_aux_has_min_c_rel</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">discard_n_cycles</span><span class="o">=</span><span class="n">discard_n_cycles</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">discard_until_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_flow_box_shaped</span><span class="p">():</span>
                <span class="n">i_init_cut</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">discard_until_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i_start_list</span><span class="p">,</span> <span class="n">i_duration</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_periodic_flow</span><span class="p">()</span>
                <span class="n">i_init_cut</span> <span class="o">=</span> <span class="n">get_cycle_start</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">discard_until_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">),</span>
                                             <span class="n">i_start_list</span><span class="p">,</span> <span class="n">i_duration</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">_aux_has_min_c</span> <span class="ow">or</span> <span class="n">_aux_has_min_c_rel</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_aux_has_min_c</span><span class="p">:</span>
                <span class="n">lim</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">&gt;=</span> <span class="n">discard_until_min_c</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> \
                    <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_lim</span> <span class="o">=</span> <span class="n">discard_until_min_c_rel</span> \
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
                <span class="n">lim</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">&gt;=</span> <span class="n">c_lim</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">lim</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_flow_box_shaped</span><span class="p">():</span>
                    <span class="n">i_init_cut</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span><span class="n">lim</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">i_start_list</span><span class="p">,</span> <span class="n">i_duration</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_periodic_flow</span><span class="p">()</span>
                    <span class="n">i_init_cut</span> <span class="o">=</span> <span class="n">get_cycle_start</span><span class="p">(</span>
                        <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span><span class="n">lim</span><span class="p">),</span>
                        <span class="n">i_start_list</span><span class="p">,</span> <span class="n">i_duration</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_aux_has_min_c</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">discard_until_min_c</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">discard_until_min_c_rel</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Threshold concentration profile&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2"> was never reached!&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span>
        <span class="k">elif</span> <span class="n">discard_n_cycles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">i_flow_on_start_list</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_assert_periodic_flow</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">i_flow_on_start_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">discard_n_cycles</span><span class="p">:</span>
                <span class="n">i_init_cut</span> <span class="o">=</span> <span class="n">i_flow_on_start_list</span><span class="p">[</span><span class="n">discard_n_cycles</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All the cycles </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">i_flow_on_start_list</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; are removed!&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="n">i_init_cut</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:</span><span class="n">i_init_cut</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_init_cut</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="UnitOperation.evaluate"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.UnitOperation.evaluate">[docs]</a>    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f_in</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">c_in</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the propagation throughout the unit operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        c_in</span>
<span class="sd">            Inlet concentration profile with shape</span>
<span class="sd">            (n_species, n_time_steps).</span>
<span class="sd">        f_in</span>
<span class="sd">            Inlet flow rate profile with shape (n_time_steps,).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f_out</span>
<span class="sd">            Outlet flow rate profile.</span>
<span class="sd">        c_out</span>
<span class="sd">            Outlet concentration profile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make a copy of inlet profiles, so we don&#39;t modify the originals.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">=</span> <span class="n">f_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">=</span> <span class="n">c_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Clear log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="c1"># Make sure concentration is not negative.</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Negative concentration at unit operation: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Make sure flow is not negative.</span>
        <span class="k">if</span> <span class="n">_np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Negative flow at unit operation: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Make sure flow is still there.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No inlet flow at unit operation: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span> <span class="o">*</span> <span class="mi">0</span>

        <span class="c1"># Calculate number of tracking species.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Cut off start if required.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cut_start_of_c_and_f</span><span class="p">(</span><span class="n">outlet</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># (Re-)calculate the outlet profiles.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calculate</span><span class="p">()</span>
        <span class="c1"># Cutoff start of outlet if needed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cut_start_of_c_and_f</span><span class="p">(</span><span class="n">outlet</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span></div>

    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">_calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Re-calculates the c_out and f_out from c_in and f_in.</span>

<span class="sd">        Function should use and modify `self._f` and `self._c`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="UnitOperation.get_result"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.UnitOperation.get_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Returns existing flow rate and concentration profiles.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        f_out</span>
<span class="sd">            Outlet flow rate profile.</span>
<span class="sd">        c_out</span>
<span class="sd">            Outlet concentration profile.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span></div></div>


<div class="viewcode-block" id="ParameterSetList"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.ParameterSetList">[docs]</a><span class="k">class</span> <span class="nc">ParameterSetList</span><span class="p">(</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for asserting keys in key-value pairs.</span>

<span class="sd">    Key-value pairs passed to `assert_and_get_provided_kv_pairs` should</span>
<span class="sd">    contain all keys from (at least) one of the key groups in</span>
<span class="sd">    `POSSIBLE_KEY_GROUPS`. The method returns key-value pars with keys</span>
<span class="sd">    from that group and all passed keys that can be also found in</span>
<span class="sd">    `OPTIONAL_KEYS`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; class DummyClass(ParameterSetList):</span>
<span class="sd">    ...    POSSIBLE_KEY_GROUPS = [[&#39;par_1&#39;], [&#39;par_2a&#39;, &#39;par_2b&#39;]]</span>
<span class="sd">    ...    OPTIONAL_KEYS = [&#39;key_plus_1&#39;, &#39;key_plus_2&#39;]</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; dc = DummyClass()</span>
<span class="sd">    &gt;&gt;&gt; dc.assert_and_get_provided_kv_pairs(par_1=1, par_2a=2)</span>
<span class="sd">    {&#39;par_1&#39;: 1}</span>
<span class="sd">    &gt;&gt;&gt; dc.assert_and_get_provided_kv_pairs(par_2a=1, par_2b=2,</span>
<span class="sd">    ...                                     key_plus_1=3, key_plus_9=2)</span>
<span class="sd">    {&#39;par_2a&#39;: 1, &#39;par_2b&#39;: 2, &#39;key_plus_1&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; dc.assert_and_get_provided_kv_pairs(</span>
<span class="sd">    ...     key_plus_1=1) # doctest: +ELLIPSIS</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    KeyError: &quot;Keys ... do not contain any of the required groups: ...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># noinspection PyPep8Naming</span>
    <span class="nd">@property</span>
    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">POSSIBLE_KEY_GROUPS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> \
            <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Possible key combinations.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        POSSIBLE_KEY_GROUPS = [[&#39;v_void&#39;], [&#39;f&#39;, &#39;rt_mean&#39;]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="c1"># noinspection PyPep8Naming</span>
    <span class="nd">@property</span>
    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">OPTIONAL_KEYS</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Optional additional keys.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        OPTIONAL_KEYS = [&#39;skew&#39;, &#39;t_delay&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="ParameterSetList.assert_and_get_provided_kv_pairs"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.ParameterSetList.assert_and_get_provided_kv_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">assert_and_get_provided_kv_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Inputs to `calc_pdf(**kwargs)` function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Filtered `**kwargs` so the keys contain first possible key</span>
<span class="sd">            group in :attr:`POSSIBLE_KEY_GROUPS` and any number of</span>
<span class="sd">            optional keys from :attr:`OPTIONAL_KEYS`.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If `**kwargs` do not contain keys from any of the groups</span>
<span class="sd">            in :attr:`POSSIBLE_KEY_GROUPS`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">POSSIBLE_KEY_GROUPS</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get keys from groups.</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">group</span><span class="p">}</span>
                <span class="c1"># Get optional keys.</span>
                <span class="n">d_extra</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">OPTIONAL_KEYS</span>
                           <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
                <span class="c1"># Combine and return.</span>
                <span class="k">return</span> <span class="p">{</span><span class="o">**</span><span class="n">d</span><span class="p">,</span> <span class="o">**</span><span class="n">d_extra</span><span class="p">}</span>

        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Keys </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2"> do not contain any of&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; the required groups: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">POSSIBLE_KEY_GROUPS</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PDF"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.PDF">[docs]</a><span class="k">class</span> <span class="nc">PDF</span><span class="p">(</span><span class="n">ParameterSetList</span><span class="p">,</span> <span class="n">DefaultLoggerLogic</span><span class="p">,</span> <span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract class for defining probability distribution functions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">    pdf_id</span>
<span class="sd">        Unique identifier of the `PDF` instance.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pdf_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pdf_id</span><span class="p">)</span>

        <span class="k">assert</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_steps_max</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># apply cutoff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trim_and_normalize</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Trim edges of the pdf and normalize it afterwards.</span>
<span class="sd">        </span>
<span class="sd">        Default = True.</span>
<span class="sd">        </span>
<span class="sd">        Relative threshold value is specified by</span>
<span class="sd">        :attr:`cutoff_relative_to_max`.</span>
<span class="sd">        </span>
<span class="sd">        Normalization is performed after the trimming.</span>
<span class="sd">        The area of pd == 1.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_relative_to_max</span> <span class="o">=</span> <span class="mf">0.0001</span>
        <span class="sd">&quot;&quot;&quot;Cutoff as a share of max value of the pdf (default 0.0001).</span>
<span class="sd">        </span>
<span class="sd">        It is defined to avoid very long tails of the distribution.</span>
<span class="sd">        </span>
<span class="sd">        Cutoff is enabled if :attr:`trim_and_normalize` == True.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># placeholder for the result of the pdf calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

    <span class="k">def</span> <span class="nf">_apply_cutoff_and_normalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Get cutoff positions.</span>
        <span class="n">i_start</span><span class="p">,</span> <span class="n">i_end</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start_and_end</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_relative_to_max</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># 0 at front.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">[:</span><span class="n">i_start</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Cut at end.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">[:</span><span class="n">i_end</span><span class="p">]</span>
        <span class="c1"># Normalize.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="p">[:</span><span class="n">i_end</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

<div class="viewcode-block" id="PDF.update_pdf"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.PDF.update_pdf">[docs]</a>    <span class="k">def</span> <span class="nf">update_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-calculate PDF based on specified parameters.</span>

<span class="sd">        The calculated probability distribution can be obtained by</span>
<span class="sd">        :func:`get_p()`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Should contain keys from one of the group in</span>
<span class="sd">            :attr:`POSSIBLE_KEY_GROUPS`.</span>
<span class="sd">            It may contain additional keys from :attr:`OPTIONAL_KEYS`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assert_and_get_provided_kv_pairs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_pdf</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim_and_normalize</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_cutoff_and_normalize</span><span class="p">()</span></div>

    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">_calc_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw_pars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Calculation of probability distribution.</span>

<span class="sd">        Evaluates pdf for a given set of parameters. The keys of the</span>
<span class="sd">        `kw_pars` include keys from one of the group in</span>
<span class="sd">        :attr:`POSSIBLE_KEY_GROUPS` and any optional subset of keys from</span>
<span class="sd">        :attr:`OPTIONAL_KEYS`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kw_pars</span>
<span class="sd">            Key-value parameters.</span>
<span class="sd">            Keys contain keys from one of the groups specified in</span>
<span class="sd">            `self.POSSIBLE_KEY_GROUPS`.</span>
<span class="sd">            Keys may contain additional keys from `self.OPTIONAL_KEYS`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="PDF.get_p"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.PDF.get_p">[docs]</a>    <span class="k">def</span> <span class="nf">get_p</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get probability distribution.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        p: ndarray</span>
<span class="sd">            Evaluated probability distribution function.</span>

<span class="sd">            Corresponding time axis starts with 0 and has a fixed step</span>
<span class="sd">            size (`_dt`).</span>

<span class="sd">            If :attr:`trim_and_normalize` == 1 then `sum(p * _dt) == 1`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;PDF is empty. Make sure `update_pdf`&quot;</span> \
                                   <span class="sa">f</span><span class="s2">&quot; was called before `get_p`.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">e</span><span class="p">(</span><span class="s2">&quot;PDF should have a length of at least 5 time steps.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pdf</span></div></div>


<div class="viewcode-block" id="ChromatographyLoadBreakthrough"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.ChromatographyLoadBreakthrough">[docs]</a><span class="k">class</span> <span class="nc">ChromatographyLoadBreakthrough</span><span class="p">(</span><span class="n">ParameterSetList</span><span class="p">,</span>
                                     <span class="n">DefaultLoggerLogic</span><span class="p">,</span> <span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;What parts of the load bind to the column.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dt</span>
<span class="sd">        Time step duration.</span>
<span class="sd">    bt_profile_id</span>
<span class="sd">        Unique identifier of the PDF instance. Used for logs.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">bt_profile_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ChromatographyLoadBreakthrough&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">bt_profile_id</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dt</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">dt</span>

<div class="viewcode-block" id="ChromatographyLoadBreakthrough.update_btc_parameters"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.ChromatographyLoadBreakthrough.update_btc_parameters">[docs]</a>    <span class="k">def</span> <span class="nf">update_btc_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update binding dynamics for a given set of parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            Should contain keys from one of the group in</span>
<span class="sd">            :attr:`POSSIBLE_KEY_GROUPS`.</span>
<span class="sd">            It may contain additional keys from :attr:`OPTIONAL_KEYS`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">assert_and_get_provided_kv_pairs</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_btc_parameters</span><span class="p">(</span><span class="n">kw</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChromatographyLoadBreakthrough.calc_c_bound"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.ChromatographyLoadBreakthrough.calc_c_bound">[docs]</a>    <span class="k">def</span> <span class="nf">calc_c_bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">c_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculates what parts of load bind to the column.</span>

<span class="sd">        The default implementation calculates cumulative mass of the</span>
<span class="sd">        load material and passes it to :func:`_update_btc_parameters`</span>
<span class="sd">        abstract method for evaluation on what shares of the load</span>
<span class="sd">        bind to the column. Those shares are then multiplied by `c_load`</span>
<span class="sd">        in order to obtain resulting `c_bound`.</span>

<span class="sd">        This method is meant to be overridden, if needed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ---------</span>
<span class="sd">        f_load</span>
<span class="sd">            Load flow rate profile.</span>
<span class="sd">        c_load</span>
<span class="sd">            Load concentration profile. Concentration profile should</span>
<span class="sd">            include only species which bind to the column.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_bound: ndarray</span>
<span class="sd">            Parts of the load that bind to the column during the</span>
<span class="sd">            load step.</span>

<span class="sd">            `c_bound` has the same shape as `c_load`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># All species are summed together.</span>
        <span class="n">m_cum_sum</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
            <span class="p">(</span><span class="n">c_load</span> <span class="o">*</span> <span class="n">f_load</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="k">if</span> <span class="n">m_cum_sum</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># empty concentration vector</span>
            <span class="k">return</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">c_load</span><span class="p">)</span>
        <span class="n">unbound_to_load_ratio</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_unbound_to_load_ratio</span><span class="p">(</span><span class="n">m_cum_sum</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="n">c_bound</span> <span class="o">=</span> <span class="n">c_load</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">unbound_to_load_ratio</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span>
        <span class="k">return</span> <span class="n">c_bound</span></div>

    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">_update_btc_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">kw_pars</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Update binding dynamics for a given key-value set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kw_pars: dict</span>
<span class="sd">            Key-value parameters.</span>
<span class="sd">            Keys contain keys from one of the groups specified in</span>
<span class="sd">            `self.POSSIBLE_KEY_GROUPS` and may contain additional keys</span>
<span class="sd">            from `self.OPTIONAL_KEYS`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">pass</span>

    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">_calc_unbound_to_load_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loaded_material</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Calculates what share of the load binds to the column.</span>

<span class="sd">        Typical implementation would be just direct evaluation of the</span>
<span class="sd">        breakthrough curve. See the `ConstantPatternSolution` subclass.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loaded_material</span>
<span class="sd">            Cumulative sum of the amount of loaded material.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bound_to_unbound_ratio</span>
<span class="sd">            Ratio between the amount of captured material and the</span>
<span class="sd">            amount of load material. `bound_to_unbound_ratio` has</span>
<span class="sd">            the same size as `loaded_material`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="ChromatographyLoadBreakthrough.get_total_bc"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.ChromatographyLoadBreakthrough.get_total_bc">[docs]</a>    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">get_total_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Total binding capacity.</span>

<span class="sd">        Meant e.g. for determining column utilization.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="RtdModel"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.RtdModel">[docs]</a><span class="k">class</span> <span class="nc">RtdModel</span><span class="p">(</span><span class="n">DefaultLoggerLogic</span><span class="p">,</span> <span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Combines `Inlet` and a train of `UnitOperation`-s into a model.</span>

<span class="sd">    The logger assigned to the instance of RtdModel is passed on to</span>
<span class="sd">    :class:`bio_rtd.core.Inlet` and</span>
<span class="sd">    :class:`bio_rtd.core.UnitOperation` instances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    inlet</span>
<span class="sd">        Inlet profile.</span>
<span class="sd">    dsp_uo_chain</span>
<span class="sd">        Sequence of unit operations. The sequence needs to be in order.</span>
<span class="sd">    logger</span>
<span class="sd">        Logger for sending status messages and storing intermediate</span>
<span class="sd">        data.</span>
<span class="sd">    title</span>
<span class="sd">        Title of the model.</span>
<span class="sd">    desc</span>
<span class="sd">        Description of the model.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`bio_rtd.core.Inlet`</span>
<span class="sd">    :class:`bio_rtd.core.UnitOperation`</span>
<span class="sd">    :class:`bio_rtd.logger.RtdLogger`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">inlet</span><span class="p">:</span> <span class="n">Inlet</span><span class="p">,</span>
                 <span class="n">dsp_uo_chain</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="n">UnitOperation</span><span class="p">],</span>
                 <span class="n">logger</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;RtdModel&quot;</span><span class="p">,</span>
                 <span class="n">desc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="c1"># Ensure unique `uo_id`s.</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span> <span class="k">for</span> <span class="n">uo</span> <span class="ow">in</span> <span class="n">dsp_uo_chain</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ids</span><span class="p">)),</span> \
            <span class="s2">&quot;Each unit operation must have a unique id (`uo_id`)&quot;</span>
        <span class="c1"># Bind parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inlet</span> <span class="o">=</span> <span class="n">inlet</span>
        <span class="sd">&quot;&quot;&quot;:class:`bio_rtd.core.Inlet`: Inlet for `self.dsp_uo_chain`&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span> <span class="o">=</span> <span class="n">dsp_uo_chain</span>
        <span class="sd">&quot;&quot;&quot;sequence of :class:`bio_rtd.core.UnitOperation`: Chain of</span>
<span class="sd">        unit operations in the process.</span>
<span class="sd">        </span>
<span class="sd">        Unit operations need to be in proper order.</span>
<span class="sd">        </span>
<span class="sd">        The logger in unit operations is overridden by the logger from</span>
<span class="sd">        this model.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">title</span>
        <span class="sd">&quot;&quot;&quot;Human readable title (mostly for plots)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc</span> <span class="o">=</span> <span class="n">desc</span>
        <span class="sd">&quot;&quot;&quot;Human readable description (also mostly for plots)&quot;&quot;&quot;</span>
        <span class="c1"># Init data log tree with empty dict for each unit operation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span> <span class="o">=</span> <span class="n">_OrderedDict</span><span class="p">(</span>
            <span class="p">{</span><span class="n">inlet</span><span class="o">.</span><span class="n">uo_id</span><span class="p">:</span> <span class="p">{},</span> <span class="o">**</span><span class="p">{</span><span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">uo</span> <span class="ow">in</span> <span class="n">dsp_uo_chain</span><span class="p">}})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logger</span> <span class="k">if</span> <span class="n">logger</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span>

<div class="viewcode-block" id="RtdModel.get_dsp_uo"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.RtdModel.get_dsp_uo">[docs]</a>    <span class="k">def</span> <span class="nf">get_dsp_uo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">UnitOperation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get reference to a `UnitOperation` with specified `uo_id`.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">uo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span> <span class="o">==</span> <span class="n">uo_id</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">uo</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unit operation `</span><span class="si">{</span><span class="n">uo_id</span><span class="si">}</span><span class="s2">` not found.</span><span class="se">\n</span><span class="s2">&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;Available: </span><span class="si">{</span><span class="p">[</span><span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span> <span class="k">for</span> <span class="n">uo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="RtdModel.recalculate"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.RtdModel.recalculate">[docs]</a>    <span class="k">def</span> <span class="nf">recalculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">start_at</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="n">on_update_callback</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span>
                        <span class="n">_typing</span><span class="o">.</span><span class="n">Callable</span><span class="p">[[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Recalculate process fluid propagation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        start_at</span>
<span class="sd">            Index of first unit operation for re-evaluation.</span>

<span class="sd">            Indexing starts at 0 (-1 for the inlet). Default = -1.</span>
<span class="sd">        on_update_callback</span>
<span class="sd">            Optional callback function which receives an integer.</span>

<span class="sd">            The integer corresponds to the index of re-evaluated unit</span>
<span class="sd">            operation, starting with 0 (-1 for inlet).</span>

<span class="sd">            This can serve as a trigger for updating UI or any other</span>
<span class="sd">            post-processing after re-evaluation of unit operations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Evaluate inlet profile.</span>
        <span class="k">if</span> <span class="n">start_at</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inlet</span><span class="o">.</span><span class="n">refresh</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_notify_updated</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">on_update_callback</span><span class="p">)</span>
            <span class="n">start_at</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Get outlet of previous unit operation.</span>
        <span class="k">if</span> <span class="n">start_at</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlet</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">[</span><span class="n">start_at</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
        <span class="c1"># Evaluate subsequent unit operations.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">)):</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_notify_updated</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">on_update_callback</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_notify_updated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uo_i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">on_update_callback</span><span class="p">):</span>
        <span class="c1"># Show INFO log.</span>
        <span class="k">if</span> <span class="n">uo_i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">uo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inlet</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i</span><span class="p">(</span><span class="s2">&quot;Inlet profile updated&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">[</span><span class="n">uo_i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unit operation `</span><span class="si">{</span><span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span><span class="si">}</span><span class="s2">` updated&quot;</span><span class="p">)</span>
        <span class="c1"># Store profiles in DEBUG data log.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">log_level</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">uo</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">[</span><span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span><span class="p">],</span> <span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">[</span><span class="n">uo</span><span class="o">.</span><span class="n">uo_id</span><span class="p">],</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="c1"># Call callback function if specified.</span>
        <span class="k">if</span> <span class="n">on_update_callback</span><span class="p">:</span>
            <span class="n">on_update_callback</span><span class="p">(</span><span class="n">uo_i</span><span class="p">)</span>

    <span class="nd">@DefaultLoggerLogic</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">set_data_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_entity_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">)</span>
        <span class="c1"># Pass logger to inlet and unit operations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inlet</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="k">for</span> <span class="n">uo</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">:</span>
            <span class="n">uo</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logger</span>

<div class="viewcode-block" id="RtdModel.set_logger_from_parent"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.RtdModel.set_logger_from_parent">[docs]</a>    <span class="k">def</span> <span class="nf">set_logger_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                               <span class="n">logger</span><span class="p">:</span> <span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="c1"># This dummy definition is here just to maintain the right order</span>
        <span class="c1"># of methods in documentation.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_logger_from_parent</span><span class="p">(</span><span class="n">parent_id</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="UserInterface"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.UserInterface">[docs]</a><span class="k">class</span> <span class="nc">UserInterface</span><span class="p">(</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper around RtdModel suitable for building GUI on top of it.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rtd_model</span>
<span class="sd">        Residence time distribution model.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`bio_rtd.core.RtdModel`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rtd_model</span><span class="p">:</span> <span class="n">RtdModel</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtd_model</span> <span class="o">=</span> <span class="n">rtd_model</span>

        <span class="c1"># default values - update them after init</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_at</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Index of first unit operation for re-evaluation.</span>
<span class="sd">                </span>
<span class="sd">        Indexing starts at 0 (-1 for the inlet). Default = -1.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">species_label</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">rtd_model</span><span class="o">.</span><span class="n">inlet</span><span class="o">.</span><span class="n">species_list</span>
        <span class="sd">&quot;&quot;&quot;Labels of the species in concentration array.</span>
<span class="sd">        </span>
<span class="sd">        Initially inherited from :class:`bio_rtd.core.Inlet` instance.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;t&#39;</span>
        <span class="sd">&quot;&quot;&quot;Label of x axis (time). Default = &#39;t&#39;&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_label_c</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;c&#39;</span>
        <span class="sd">&quot;&quot;&quot;Label of y axis (concentration). Default = &#39;c&#39;&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_label_f</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;f&#39;</span>
        <span class="sd">&quot;&quot;&quot;Label of y axis (flow rate). Default = &#39;f&#39;&quot;&quot;&quot;</span>

<div class="viewcode-block" id="UserInterface.recalculate"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.UserInterface.recalculate">[docs]</a>    <span class="k">def</span> <span class="nf">recalculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forced</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Re-evaluates the model from the `start_at` index onwards.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forced</span>
<span class="sd">            If true, the entire model (inlet + unit operations) is</span>
<span class="sd">            re-evaluated. The same can be achieved by setting</span>
<span class="sd">            :attr:`start_at` to -1.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start_at</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="n">forced</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_at</span>

        <span class="k">def</span> <span class="nf">callback_fun</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd_model</span><span class="o">.</span><span class="n">inlet</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtd_model</span><span class="o">.</span><span class="n">dsp_uo_chain</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_ui_for_uo</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="c1"># Re-calculate the model.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtd_model</span><span class="o">.</span><span class="n">recalculate</span><span class="p">(</span><span class="n">start_at</span><span class="p">,</span> <span class="n">callback_fun</span><span class="p">)</span></div>

<div class="viewcode-block" id="UserInterface.build_ui"><a class="viewcode-back" href="../../bio_rtd/core.html#bio_rtd.core.UserInterface.build_ui">[docs]</a>    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">build_ui</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Build the UI from scratch.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="nd">@_abstractmethod</span>
    <span class="k">def</span> <span class="nf">_update_ui_for_uo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uo_i</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>  <span class="c1"># pragma: no cover</span>
        <span class="sd">&quot;&quot;&quot;Update the UI for specific unit operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        uo_i: int</span>
<span class="sd">            Index of unit operation (-1 for inlet profile).</span>
<span class="sd">            Indexes for DSP unit operation train start with 0.</span>
<span class="sd">        c: _np.ndarray</span>
<span class="sd">            Outlet concentration profile.</span>
<span class="sd">        f: _np.ndarray</span>
<span class="sd">            Outlet flow profile.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2020, University of Natural Resources and Life Sciences (BOKU), Vienna.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>