

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bio_rtd.uo.sc_uo &mdash; bio_rtd  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../content.html" class="icon icon-home"> bio_rtd
          

          
          </a>

          
            
            
              <div class="version">
                0.7.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">Home</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../user_guide.html">User Guide</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference.html">API Reference</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../content.html">bio_rtd</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../content.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>bio_rtd.uo.sc_uo</li>
    
    

  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for bio_rtd.uo.sc_uo</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Semi continuous unit operations.</span>

<span class="sd">Unit operations that accept constant or box-shaped flow rate profile</span>
<span class="sd">and provide periodic flow rate profile.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;AlternatingChromatography&#39;</span><span class="p">,</span> <span class="s1">&#39;ACC&#39;</span><span class="p">,</span> <span class="s1">&#39;PCC&#39;</span><span class="p">,</span> <span class="s1">&#39;PCCWithWashDesorption&#39;</span><span class="p">]</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s1">&#39;0.7.1&#39;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Jure Sencar&#39;</span>

<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">_typing</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">_np</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">_interp</span>

<span class="kn">from</span> <span class="nn">bio_rtd.chromatography</span> <span class="kn">import</span> <span class="n">bt_load</span> <span class="k">as</span> <span class="n">_bt_load</span>
<span class="kn">import</span> <span class="nn">bio_rtd.utils</span> <span class="k">as</span> <span class="nn">_utils</span>
<span class="kn">import</span> <span class="nn">bio_rtd.core</span> <span class="k">as</span> <span class="nn">_core</span>
<span class="kn">import</span> <span class="nn">bio_rtd.pdf</span> <span class="k">as</span> <span class="nn">_pdf</span>


<div class="viewcode-block" id="AlternatingChromatography"><a class="viewcode-back" href="../../../bio_rtd/uo.sc_uo.html#bio_rtd.uo.sc_uo.AlternatingChromatography">[docs]</a><span class="k">class</span> <span class="nc">AlternatingChromatography</span><span class="p">(</span><span class="n">_core</span><span class="o">.</span><span class="n">UnitOperation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulation of alternating chromatography.</span>

<span class="sd">    This class implements logic common to various types of alternating</span>
<span class="sd">    chromatography. It has a role of a base class for</span>
<span class="sd">    specific types of alternating chromatography to extend.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">        Starts with 0 and has a constant time step.</span>
<span class="sd">    uo_id</span>
<span class="sd">        Unique identifier.</span>
<span class="sd">    load_bt</span>
<span class="sd">        Load breakthrough logic.</span>
<span class="sd">    peak_shape_pdf</span>
<span class="sd">        Elution peak shape.</span>
<span class="sd">    gui_title</span>
<span class="sd">        Readable title for GUI. Default = &quot;AC&quot;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    **Quick description of which attributes are available:**</span>

<span class="sd">    Non-binding species (optional):</span>

<span class="sd">    * :attr:`non_binding_species`</span>

<span class="sd">    Column volume (exactly one required):</span>

<span class="sd">    * :attr:`cv`</span>
<span class="sd">    * :attr:`ft_mean_retentate` and :attr:`column_porosity_retentate`</span>

<span class="sd">    Column porosity for binding species (required in case of</span>
<span class="sd">    :attr:`ft_mean_retentate` or wash or load recycling):</span>

<span class="sd">    * :attr:`column_porosity_retentate`</span>

<span class="sd">    Equilibration step duration (optional, if both, the values are</span>
<span class="sd">    added together):</span>

<span class="sd">    * :attr:`equilibration_cv`</span>
<span class="sd">    * :attr:`equilibration_t`</span>

<span class="sd">    Equilibration step flow rate (exactly one needed):</span>

<span class="sd">    * :attr:`equilibration_f` - absolute, has priority if defined</span>
<span class="sd">    * :attr:`equilibration_f_rel` - relative, default = 1</span>

<span class="sd">    Load step duration:</span>

<span class="sd">    * :attr:`load_cv` - preferred</span>
<span class="sd">    * :attr:`load_c_end_ss` - concentration limit for breakthrough; also</span>
<span class="sd">      requires :attr:`load_recycle_pdf`</span>
<span class="sd">    * :attr:`load_c_end_relative_ss` - concentration limit for</span>
<span class="sd">      breakthrough relative to steady-state load concentration; also</span>
<span class="sd">      requires :attr:`load_recycle_pdf`</span>

<span class="sd">    Iterative optimization of estimation of load step duration</span>
<span class="sd">    (ignored if :attr:`load_cv` is defined):</span>

<span class="sd">    * :attr:`load_c_end_estimate_with_iterative_solver` - default = True</span>
<span class="sd">    * :attr:`load_c_end_estimate_with_iter_solver_max_iter` - default =</span>
<span class="sd">      1000</span>

<span class="sd">    Extension of first load step (optional; ignored if no recycling):</span>

<span class="sd">    * :attr:`load_extend_first_cycle` - default = `False`</span>
<span class="sd">    * :attr:`load_extend_first_cycle_cv` and</span>
<span class="sd">      :attr:`load_extend_first_cycle_t` - added together if both defined</span>

<span class="sd">    Load linear velocity - only for column height determination</span>
<span class="sd">    (optional):</span>

<span class="sd">    * :attr:`load_target_lin_velocity`</span>

<span class="sd">    Wash step duration (optional, if both, the values are</span>
<span class="sd">    added together):</span>

<span class="sd">    * :attr:`wash_cv`</span>
<span class="sd">    * :attr:`wash_t`</span>

<span class="sd">    Wash step flow rate (exactly one needed):</span>

<span class="sd">    * :attr:`wash_f` - absolute, has priority if defined</span>
<span class="sd">    * :attr:`wash_f_rel` - relative, default = 1</span>

<span class="sd">    Unaccounted losses - applied before peak cut (optional):</span>

<span class="sd">    * :attr:`unaccounted_losses_rel` - relative, default = 1</span>

<span class="sd">    Elution step duration (optional, if both, the values are</span>
<span class="sd">    added together):</span>

<span class="sd">    * :attr:`elution_cv`</span>
<span class="sd">    * :attr:`elution_t`</span>

<span class="sd">    Elution step flow rate (exactly one needed):</span>

<span class="sd">    * :attr:`elution_f` - absolute, has priority if defined</span>
<span class="sd">    * :attr:`elution_f_rel` - relative, default = 1</span>

<span class="sd">    Elution buffer composition (optional):</span>

<span class="sd">    * :attr:`elution_buffer_c`</span>


<span class="sd">    Elution peak position duration - first momentum</span>
<span class="sd">    (optional, if both, the values are added together):</span>

<span class="sd">    * :attr:`elution_peak_position_cv`</span>
<span class="sd">    * :attr:`elution_peak_position_t`</span>

<span class="sd">    Elution peak cut start (one is required):</span>

<span class="sd">    * :attr:`elution_peak_cut_start_t`</span>
<span class="sd">    * :attr:`elution_peak_cut_start_cv`</span>
<span class="sd">    * :attr:`elution_peak_cut_start_c_rel_to_peak_max`</span>
<span class="sd">    * :attr:`elution_peak_cut_start_peak_area_share`</span>

<span class="sd">    Elution peak cut end (one is required):</span>

<span class="sd">    * :attr:`elution_peak_cut_end_t`</span>
<span class="sd">    * :attr:`elution_peak_cut_end_cv`</span>
<span class="sd">    * :attr:`elution_peak_cut_end_c_rel_to_peak_max`</span>
<span class="sd">    * :attr:`elution_peak_cut_end_peak_area_share`</span>

<span class="sd">    Regeneration step duration (optional, if both, the values are</span>
<span class="sd">    added together):</span>

<span class="sd">    * :attr:`regeneration_cv`</span>
<span class="sd">    * :attr:`regeneration_t`</span>

<span class="sd">    Regeneration step flow rate (exactly one needed):</span>

<span class="sd">    * :attr:`regeneration_f` - absolute, has priority if defined</span>
<span class="sd">    * :attr:`regeneration_f_rel` - relative, default = 1</span>

<span class="sd">    Wash desorption (optional, also check if class supports it):</span>

<span class="sd">    * :attr:`wash_desorption` - default = `False`</span>

<span class="sd">    Load breakthrough recycle (optional):</span>

<span class="sd">    * :attr:`load_recycle` - default = `False`</span>

<span class="sd">    Load breakthrough propagation dynamics</span>
<span class="sd">    (required if :attr:`load_recycle` is `True`</span>
<span class="sd">    or :attr:`load_c_end_ss` is defined or</span>
<span class="sd">    or :attr:`load_c_end_relative_ss` is defined):</span>

<span class="sd">    * :attr:`load_recycle_pdf`</span>

<span class="sd">    Wash recycle (optional):</span>

<span class="sd">    * :attr:`wash_recycle` - default = `False`</span>

<span class="sd">    Duration of wash recycling</span>
<span class="sd">    (optional; ignored if :attr:`wash_recycle` is `False`):</span>

<span class="sd">    * :attr:`wash_recycle_duration_cv` and</span>
<span class="sd">      :attr:`wash_recycle_duration_t` - summed together if both defined.</span>
<span class="sd">    * Entire wash step if</span>
<span class="sd">      :attr:`wash_recycle_duration_cv` and</span>
<span class="sd">      :attr:`wash_recycle_duration_t` are not defined.</span>


<span class="sd">    Please note that subclasses might introduce new attributes or change</span>
<span class="sd">    the default values of existing attributes.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">load_bt</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">ChromatographyLoadBreakthrough</span><span class="p">,</span>
                 <span class="n">peak_shape_pdf</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">,</span>
                 <span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;AC&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">uo_id</span><span class="p">,</span> <span class="n">gui_title</span><span class="p">)</span>
        <span class="c1"># Bind parameters.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">ChromatographyLoadBreakthrough</span> <span class="o">=</span> <span class="n">load_bt</span>
        <span class="sd">&quot;&quot;&quot;Determines what part of load material binds to the column.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_shape</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span> <span class="o">=</span> <span class="n">peak_shape_pdf</span>
        <span class="sd">&quot;&quot;&quot;Elution peak shape.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="sd">&quot;&quot;&quot;Process buffer species that are NOT binding to the column.</span>
<span class="sd">        </span>
<span class="sd">        Indexing starts with 0.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Column volume.</span>
<span class="sd">        </span>
<span class="sd">        Column volume should be defined by exactly one of the following</span>
<span class="sd">        attribute groups:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`cv` (this one)</span>
<span class="sd">        * :attr:`ft_mean_retentate`</span>
<span class="sd">          and :attr:`column_porosity_retentate`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ft_mean_retentate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Flow-through time of retentate under non-binding conditions.</span>
<span class="sd">        </span>
<span class="sd">        Used to define column volume (independently of scale).</span>
<span class="sd">        </span>
<span class="sd">        Column volume should be defined by exactly one of the following</span>
<span class="sd">        attribute groups:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`cv`</span>
<span class="sd">        * :attr:`ft_mean_retentate` (this one) and </span>
<span class="sd">          :attr:`column_porosity_retentate`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_porosity_retentate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Column porosity for retentate under non-binding conditions.</span>
<span class="sd">        </span>
<span class="sd">        Required in case :attr:`ft_mean_retentate` is used to define</span>
<span class="sd">        column volume.</span>
<span class="sd">        </span>
<span class="sd">        Required in case :attr:`load_c_end_ss` or</span>
<span class="sd">        :attr:`load_c_end_relative_ss` are used to estimate</span>
<span class="sd">        load step duration.</span>
<span class="sd">        </span>
<span class="sd">        Required in case of load or wash recycling.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of equilibration step.</span>
<span class="sd">        </span>
<span class="sd">        The values of :attr:`equilibration_t` and </span>
<span class="sd">        :attr:`equilibration_cv` are added together.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of equilibration step.</span>
<span class="sd">        </span>
<span class="sd">        The values of :attr:`equilibration_t` and </span>
<span class="sd">        :attr:`equilibration_cv` are added together.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_f</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Equilibration step flow rate.</span>
<span class="sd">        </span>
<span class="sd">        Equilibration step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`equilibration_f` (this one)</span>
<span class="sd">        * :attr:`equilibration_f_rel`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_f_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Equilibration step flow rate relative to load flow rate.</span>
<span class="sd">        </span>
<span class="sd">        Default = 1.</span>
<span class="sd">        </span>
<span class="sd">        Equilibration step flow rate = :attr:`equilibration_f_rel`</span>
<span class="sd">        * `load flow rate`</span>
<span class="sd">        </span>
<span class="sd">        Equilibration step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`equilibration_f`</span>
<span class="sd">        * :attr:`equilibration_f_rel` (this one)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Duration of the load phase.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># load duration in CV</span>
        <span class="sd">&quot;&quot;&quot;Load phase duration in CV.</span>
<span class="sd">        </span>
<span class="sd">        This is preferable way to define the duration of the load step</span>
<span class="sd">        as it does not require any estimations about steady state.</span>
<span class="sd">        </span>
<span class="sd">        Load phase duration should be defined by exactly one of</span>
<span class="sd">        the following attribute groups:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`load_cv` (this one)</span>
<span class="sd">        * :attr:`load_c_end_ss`</span>
<span class="sd">        * :attr:`load_c_end_relative_ss`</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        First load step can be extended by setting</span>
<span class="sd">        :attr:`load_extend_first_cycle`,</span>
<span class="sd">        :attr:`load_extend_first_cycle_cv` and</span>
<span class="sd">        :attr:`load_extend_first_cycle_t`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_ss</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;Load phase switch based on target product breakthrough conc.</span>
<span class="sd">        </span>
<span class="sd">        Load phase duration is estimated from simulating steady state</span>
<span class="sd">        operation and determining when the breakthrough reaches</span>
<span class="sd">        specified concentration.</span>
<span class="sd">        </span>
<span class="sd">        Steady state simulation requires</span>
<span class="sd">        :attr:`column_porosity_retentate`</span>
<span class="sd">        :attr:`load_recycle_pdf`.</span>
<span class="sd">        </span>
<span class="sd">        Load phase duration should be defined by exactly one of</span>
<span class="sd">        the following attribute groups:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`load_cv` (preferred)</span>
<span class="sd">        * :attr:`load_c_end_ss` (this one)</span>
<span class="sd">        * :attr:`load_c_end_relative_ss`</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        First load step can be extended by setting</span>
<span class="sd">        :attr:`load_extend_first_cycle`,</span>
<span class="sd">        :attr:`load_extend_first_cycle_cv` and</span>
<span class="sd">        :attr:`load_extend_first_cycle_t`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_relative_ss</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Load phase switch based on relative breakthrough conc.</span>
<span class="sd">        </span>
<span class="sd">        Load phase duration is estimated from simulating steady state</span>
<span class="sd">        operation and determining when the product (binding species)</span>
<span class="sd">        in the breakthrough reaches specified relative concentration</span>
<span class="sd">        (relative to load concentration in steady-state operation).</span>
<span class="sd">        </span>
<span class="sd">        Steady state simulation requires</span>
<span class="sd">        :attr:`column_porosity_retentate`</span>
<span class="sd">        :attr:`load_recycle_pdf`.</span>
<span class="sd">        </span>
<span class="sd">        Load phase duration should be defined by exactly one of</span>
<span class="sd">        the following attribute groups:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`load_cv` (preferred)</span>
<span class="sd">        * :attr:`load_c_end_ss`</span>
<span class="sd">        * :attr:`load_c_end_relative_ss` (this one)</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        First load step can be extended by setting</span>
<span class="sd">        :attr:`load_extend_first_cycle`,</span>
<span class="sd">        :attr:`load_extend_first_cycle_cv` and</span>
<span class="sd">        :attr:`load_extend_first_cycle_t`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iterative_solver</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Finer optimization of cycle length estimation.</span>
<span class="sd">        </span>
<span class="sd">        Default = `True`.</span>
<span class="sd">        </span>
<span class="sd">        In case load step duration is estimated based of breakthrough</span>
<span class="sd">        criteria (i.e. by :attr:`load_c_end_ss` or</span>
<span class="sd">        :attr:`load_c_end_relative_ss`), the model needs to simulate</span>
<span class="sd">        steady-state operation in order to determine fixed load time.</span>
<span class="sd">        This parameters enables iterative solver that allows more</span>
<span class="sd">        precise estimation but might slow down the simulation.</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Max number of iteration steps is defined by</span>
<span class="sd">        :attr:`load_c_end_estimate_with_iter_solver_max_iter`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iter_solver_max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="sd">&quot;&quot;&quot;Max steps for optimization of cycle length estimation.</span>
<span class="sd">        </span>
<span class="sd">        Default = 1000.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :attr:`load_c_end_estimate_with_iterative_solver`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Extend first load phase to achieve a faster steady-state.</span>
<span class="sd">        </span>
<span class="sd">        Only relevant in case wash or load is recycled.</span>
<span class="sd">        </span>
<span class="sd">        The duration of extension is defined by:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`load_extend_first_cycle_cv` or</span>
<span class="sd">        * :attr:`load_extend_first_cycle_t` or</span>
<span class="sd">        * is determined automatically.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of first load phase extension in column volumes.</span>
<span class="sd">        </span>
<span class="sd">        Only relevant if :attr:`load_extend_first_cycle` is `True`.</span>
<span class="sd">        </span>
<span class="sd">        If the duration if defined by</span>
<span class="sd">        :attr:`load_extend_first_cycle_cv` and</span>
<span class="sd">        :attr:`load_extend_first_cycle_t`</span>
<span class="sd">        then the values are added together.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of first load phase extension (time).</span>
<span class="sd">        </span>
<span class="sd">        Only relevant if :attr:`load_extend_first_cycle` is `True`.</span>
<span class="sd">        </span>
<span class="sd">        If the duration if defined by</span>
<span class="sd">        :attr:`load_extend_first_cycle_cv` and</span>
<span class="sd">        :attr:`load_extend_first_cycle_t`</span>
<span class="sd">        then the values are added together.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_target_lin_velocity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Target load linear velocity.</span>
<span class="sd">        </span>
<span class="sd">        It is used to provide information about required column height.</span>
<span class="sd">        </span>
<span class="sd">        It does not have any impact on the rest of the model.</span>
<span class="sd">        </span>
<span class="sd">        Units need to match other units in the model.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of wash step.</span>

<span class="sd">        The values of :attr:`wash_t` and </span>
<span class="sd">        :attr:`wash_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of wash step.</span>

<span class="sd">        The values of :attr:`wash_t` and </span>
<span class="sd">        :attr:`wash_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_f</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Wash step flow rate.</span>

<span class="sd">        Wash step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>

<span class="sd">        * :attr:`wash_f` (this one)</span>
<span class="sd">        * :attr:`wash_f_rel`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_f_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Wash step flow rate relative to load flow rate. Default = 1.</span>

<span class="sd">        Wash step flow rate = :attr:`wash_f_rel`</span>
<span class="sd">        * `load flow rate`</span>

<span class="sd">        Wash step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>

<span class="sd">        * :attr:`wash_f`</span>
<span class="sd">        * :attr:`wash_f_rel` (this one)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unaccounted_losses_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="sd">&quot;&quot;&quot;Unaccounted losses as a share of bound material.</span>
<span class="sd">        </span>
<span class="sd">        Elution peak is scaled down by 1 - `unaccounted_losses_rel`</span>
<span class="sd">        before applying peak cut criteria.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of elution step.</span>

<span class="sd">        The values of :attr:`elution_t` and </span>
<span class="sd">        :attr:`elution_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of elution step.</span>

<span class="sd">        The values of :attr:`elution_t` and </span>
<span class="sd">        :attr:`elution_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_f</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution step flow rate.</span>

<span class="sd">        Elution step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>

<span class="sd">        * :attr:`elution_f` (this one)</span>
<span class="sd">        * :attr:`elution_f_rel`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_f_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution step flow rate relative to load flow rate.</span>

<span class="sd">        Default = 1.</span>

<span class="sd">        Elution step flow rate = :attr:`elution_f_rel`</span>
<span class="sd">        * `load flow rate`</span>

<span class="sd">        Elution step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>

<span class="sd">        * :attr:`elution_f`</span>
<span class="sd">        * :attr:`elution_f_rel` (this one)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_buffer_c</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="sd">&quot;&quot;&quot;Elution buffer composition.</span>
<span class="sd">        </span>
<span class="sd">        Default = empty array (= all components are 0).</span>
<span class="sd">        </span>
<span class="sd">        If defined it must have a value for each specie.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_position_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Position (cv) of elution peak in the elution step.</span>
<span class="sd">        </span>
<span class="sd">        This is for 1st moment or mean residence time (and not</span>
<span class="sd">        necessarily peak max position).</span>

<span class="sd">        The values of :attr:`elution_peak_position_t` and </span>
<span class="sd">        :attr:`elution_peak_position_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_position_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Position (time) of elution peak in the elution step.</span>
<span class="sd">        </span>
<span class="sd">        This is for 1st moment or mean residence time (and not</span>
<span class="sd">        necessarily peak max position).</span>

<span class="sd">        The values of :attr:`elution_peak_position_t` and </span>
<span class="sd">        :attr:`elution_peak_position_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut start (time).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut start criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut start (cv).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut start criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_c_rel_to_peak_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut start (signal relative to peak max).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut start criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_peak_area_share</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut start (share of total peak area).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut start criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut end (time).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut end criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut end (cv).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut end criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_c_rel_to_peak_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut end (signal relative to peak max).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut end criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_peak_area_share</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Elution peak cut end (share of total peak area).</span>
<span class="sd">        </span>
<span class="sd">        Exactly one peak cut end criteria should be defined.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of regeneration step.</span>

<span class="sd">        The values of :attr:`regeneration_t` and </span>
<span class="sd">        :attr:`regeneration_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of regeneration step.</span>

<span class="sd">        The values of :attr:`regeneration_t` and </span>
<span class="sd">        :attr:`regeneration_cv` are added together.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_f</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Regeneration step flow rate.</span>

<span class="sd">        Regeneration step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>

<span class="sd">        * :attr:`regeneration_f` (this one)</span>
<span class="sd">        * :attr:`regeneration_f_rel`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_f_rel</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Regeneration step flow rate relative to load flow rate.</span>
<span class="sd">        </span>
<span class="sd">        Default = 1.</span>

<span class="sd">        Regeneration step flow rate = :attr:`regeneration_f_rel`</span>
<span class="sd">        * `load flow rate`</span>

<span class="sd">        Regeneration step flow rate should be defined by</span>
<span class="sd">        exactly one of the following attributes:</span>

<span class="sd">        * :attr:`regeneration_f`</span>
<span class="sd">        * :attr:`regeneration_f_rel` (this one)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Enable wash desorption.</span>
<span class="sd">        </span>
<span class="sd">        Make sure the class implements the desorption dynamics.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Recycle load breakthrough. Default = False.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="sd">&quot;&quot;&quot;PDF of wash and/or unbound load traveling through the column.</span>
<span class="sd">        </span>
<span class="sd">        The unbound (not captured) part and desorbed part are propagated</span>
<span class="sd">        through the column by :attr:`load_recycle_pdf`.</span>

<span class="sd">        Void volume for :attr:`load_recycle_pdf` is defined as</span>
<span class="sd">        :attr:`column_porosity_retentate` * `column volume`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Recycle wash. Default = False.</span>
<span class="sd">        </span>
<span class="sd">        Wash is recycled onto 3rd column while the 2nd is on load step.</span>
<span class="sd">        After the wash recycle, the 3rd column is connected to 2nd</span>
<span class="sd">        column to recycle load breakthrough material.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle_duration_cv</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of wash recycle (cv).</span>
<span class="sd">        </span>
<span class="sd">        Relevant if :attr:`wash_recycle` is `True`.</span>
<span class="sd">        </span>
<span class="sd">        If both (`wash_recycle_duration_cv` and</span>
<span class="sd">        :attr:`wash_recycle_duration_t`) are defined, then the values</span>
<span class="sd">        are added together. If none of those is defined, then the</span>
<span class="sd">        entire wash step is recycled.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle_duration_t</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Duration of wash recycle (time).</span>
<span class="sd">        </span>
<span class="sd">        Relevant if :attr:`wash_recycle` is `True`.</span>
<span class="sd">        </span>
<span class="sd">        If both (`wash_recycle_duration_t` and</span>
<span class="sd">        :attr:`wash_recycle_duration_cv`) are defined, then the values</span>
<span class="sd">        are added together. If none of those is defined, then the</span>
<span class="sd">        entire wash step is recycled.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="nd">@_core</span><span class="o">.</span><span class="n">UnitOperation</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">RtdLogger</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Propagates logger across other elements that support it.&quot;&quot;&quot;</span>
        <span class="c1"># Default logic.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span><span class="o">.</span><span class="n">set_data_tree</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_entity_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">)</span>
        <span class="c1"># Propagate logger across other elements with logging.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span><span class="o">.</span><span class="n">set_logger_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_shape</span><span class="o">.</span><span class="n">set_logger_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">set_logger_from_parent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uo_id</span><span class="p">,</span> <span class="n">logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_flow_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">step_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                        <span class="n">flow</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">rel_flow</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calc flow rate of chromatographic step.</span>

<span class="sd">        If `flow` is specified, `flow` is used.</span>
<span class="sd">        Otherwise `rel_flow` == flow rate relative to load flow rate is</span>
<span class="sd">        used.</span>

<span class="sd">        If none are positive, then the load flow rate is used</span>
<span class="sd">        and a warning is logged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step_name</span>
<span class="sd">            Step name (e.g. &quot;Wash&quot;) for log messages.</span>
<span class="sd">        var_name</span>
<span class="sd">            Step variable name (e.g. &quot;wash_t&quot;) for log data.</span>
<span class="sd">        flow</span>
<span class="sd">            Flow rate.</span>
<span class="sd">        rel_flow</span>
<span class="sd">            Flow rate relative to load flow rate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Flow rate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rel_flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">rel_flow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">flow</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step_name</span><span class="si">}</span><span class="s2"> step flow rate is not defined,&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; using load flow rate instead.&quot;</span><span class="p">)</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
        <span class="k">return</span> <span class="n">flow</span>

    <span class="k">def</span> <span class="nf">_get_time_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">step_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                        <span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">cv</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">flow</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calc duration of chromatographic step.</span>

<span class="sd">        If the step duration is specified in cv and in t, then the</span>
<span class="sd">        value are added together.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        step_name</span>
<span class="sd">            Step name (e.g. &quot;Wash&quot;) for log messages.</span>
<span class="sd">        var_name</span>
<span class="sd">            Step variable name (e.g. &quot;wash_t&quot;) for log data.</span>
<span class="sd">        t</span>
<span class="sd">            Duration (time).</span>
<span class="sd">        cv</span>
<span class="sd">            Duration (cv).</span>
<span class="sd">        flow</span>
<span class="sd">            Flow rate (required if `cv` &gt; 0).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Total step duration (time).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calc.</span>
        <span class="n">t_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">flow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step_name</span><span class="si">}</span><span class="s2">: Flow rate must be defined (&gt; 0)&quot;</span> \
                             <span class="sa">f</span><span class="s2">&quot; if the duration is specified in CVs.&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;CV must be determined (by `calc_cv`)&quot;</span> \
                                 <span class="sa">f</span><span class="s2">&quot; before calculating duration based on CVs.&quot;</span>
            <span class="n">t_sum</span> <span class="o">+=</span> <span class="n">cv</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="n">flow</span>  <span class="c1"># sum</span>
        <span class="c1"># Log.</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">cv</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="n">step_name</span> <span class="o">+</span> <span class="s2">&quot; time is not defined&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">t_sum</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t_sum</span>

    <span class="k">def</span> <span class="nf">_assert_non_binding_species</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make sure binding species list is valid.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> \
                <span class="s2">&quot;Index of non_binding_species too large (indexes start with 0)&quot;</span>
            <span class="k">assert</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">))</span> \
                <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">),</span> \
                <span class="s2">&quot;List of non_binding_species should have ascending order&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> \
                <span class="s2">&quot;All species cannot be non-binding.&quot;</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s1">&#39;non_binding_species&#39;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_load_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine load flow rate (when on).&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_flow_box_shaped</span><span class="p">(),</span> <span class="s2">&quot;Inlet flow must be box shaped.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;load_f&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine column volume.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_single_non_negative_parameter</span><span class="p">(</span>
            <span class="n">log_level_multiple</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">log_level_none</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span>
            <span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cv</span><span class="p">,</span>
            <span class="n">ft_mean_retentate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ft_mean_retentate</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cv</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># `self.ft_mean_retentate` &gt; 0.</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_porosity_retentate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;porosity_retentate must be defined to calc CV from &quot;</span> \
                <span class="sa">f</span><span class="s2">&quot; `self.ft_mean_retentate`.&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Load flow rate must be defined to&quot;</span> \
                                     <span class="sa">f</span><span class="s2">&quot; calc CV from `self.ft_mean_retentate`.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ft_mean_retentate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> \
                <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_porosity_retentate</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;cv&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_report_column_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Report column dimensions based on load linear velocity.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_target_lin_velocity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_col_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_target_lin_velocity</span> \
                          <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s2">&quot;column_h&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_h</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                            <span class="s2">&quot;column_d&quot;</span><span class="p">,</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_h</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_equilibration_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine equilibration step duration.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Flow rate.</span>
            <span class="n">eq_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flow_value</span><span class="p">(</span><span class="s2">&quot;Equilibration&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;equilibration_f&quot;</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_f</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_f_rel</span><span class="p">)</span>
            <span class="c1"># Duration.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_equilibration_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_value</span><span class="p">(</span><span class="s2">&quot;Equilibration&quot;</span><span class="p">,</span>
                                                         <span class="s2">&quot;equilibration_t&quot;</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_t</span><span class="p">,</span>
                                                         <span class="bp">self</span><span class="o">.</span><span class="n">equilibration_cv</span><span class="p">,</span>
                                                         <span class="n">eq_f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Duration.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_equilibration_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">equilibration_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s1">&#39;equilibration_t&#39;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_equilibration_t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_wash_t_and_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine wash step flow rate and duration.&quot;&quot;&quot;</span>
        <span class="c1"># Flow rate.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flow_value</span><span class="p">(</span><span class="s2">&quot;Wash&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;wash_f&quot;</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">wash_f</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">wash_f_rel</span><span class="p">)</span>
        <span class="c1"># Duration.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_value</span><span class="p">(</span><span class="s2">&quot;Wash&quot;</span><span class="p">,</span>
                                            <span class="s2">&quot;wash_t&quot;</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">wash_t</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">wash_cv</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_elution_t_and_f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine elution step flow rate and duration.&quot;&quot;&quot;</span>
        <span class="c1"># Flow rate.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flow_value</span><span class="p">(</span><span class="s2">&quot;Elution&quot;</span><span class="p">,</span>
                                               <span class="s2">&quot;elution_f&quot;</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">elution_f</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">elution_f_rel</span><span class="p">)</span>
        <span class="c1"># Duration.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_value</span><span class="p">(</span><span class="s2">&quot;Elution&quot;</span><span class="p">,</span>
                                               <span class="s2">&quot;elution_t&quot;</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">elution_t</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">elution_cv</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_elution_peak_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine elution peak mean position (1st momentum).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_value</span><span class="p">(</span>
            <span class="s2">&quot;elution peak position&quot;</span><span class="p">,</span>
            <span class="s2">&quot;elution_peak_position_t&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_position_t</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_position_cv</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_elution_peak_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update elution peak PDF.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># Calc elution peak shape.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_shape</span><span class="o">.</span><span class="n">update_pdf</span><span class="p">(</span>
            <span class="n">rt_mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_t</span><span class="p">,</span>
            <span class="n">v_void</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_t</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span><span class="p">,</span>
            <span class="n">f</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_elution_peak</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_shape</span><span class="o">.</span><span class="n">get_p</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">unaccounted_losses_rel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;p_elution_peak&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_p_elution_peak</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_elution_peak_cut_i_start_and_i_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calc elution peak cut start and end in form of time steps.</span>

<span class="sd">        Values are relative to the beginning of the elution step.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elution_peak_pdf</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_elution_peak</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Peak cut start.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_single_non_negative_parameter</span><span class="p">(</span>
            <span class="n">log_level_multiple</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">log_level_none</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
            <span class="n">elution_peak_cut_start_peak_area_share</span><span class="o">=</span><span class="bp">self</span>
            <span class="o">.</span><span class="n">elution_peak_cut_start_peak_area_share</span><span class="p">,</span>
            <span class="n">elution_peak_cut_start_c_rel_to_peak_max</span><span class="o">=</span><span class="bp">self</span>
            <span class="o">.</span><span class="n">elution_peak_cut_start_c_rel_to_peak_max</span><span class="p">,</span>
            <span class="n">elution_peak_cut_start_cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_cv</span><span class="p">,</span>
            <span class="n">elution_peak_cut_start_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_t</span>
        <span class="p">)</span>
        <span class="c1"># Calc `elution_peak_cut_start_i`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_peak_area_share</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_start_i</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                <span class="n">_np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">elution_peak_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
                <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_peak_area_share</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_c_rel_to_peak_max</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_start_i</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                <span class="n">elution_peak_pdf</span>
                <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_c_rel_to_peak_max</span>
                <span class="o">*</span> <span class="n">elution_peak_pdf</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_cv</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_start_i</span> <span class="o">=</span> \
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_cv</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_start_i</span> <span class="o">=</span> \
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_start_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Elution peak cut start is not defined.&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; Now collecting from the beginning&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; of the elution phase.&quot;</span><span class="p">)</span>
            <span class="n">elution_peak_cut_start_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;elution_peak_cut_start_i&quot;</span><span class="p">,</span>
                        <span class="n">elution_peak_cut_start_i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;elution_peak_cut_start_t&quot;</span><span class="p">,</span>
                        <span class="n">elution_peak_cut_start_i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
        <span class="c1"># Peak cut end.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_single_non_negative_parameter</span><span class="p">(</span>
            <span class="n">log_level_multiple</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">log_level_none</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">WARNING</span><span class="p">,</span>
            <span class="n">elution_peak_cut_end_peak_area_share</span><span class="o">=</span><span class="bp">self</span>
            <span class="o">.</span><span class="n">elution_peak_cut_end_peak_area_share</span><span class="p">,</span>
            <span class="n">elution_peak_cut_end_c_rel_to_peak_max</span><span class="o">=</span><span class="bp">self</span>
            <span class="o">.</span><span class="n">elution_peak_cut_end_c_rel_to_peak_max</span><span class="p">,</span>
            <span class="n">elution_peak_cut_end_cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_cv</span><span class="p">,</span>
            <span class="n">elution_peak_cut_end_t</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_t</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Calc `elution_peak_cut_end_i`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_peak_area_share</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_end_i</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                <span class="n">_np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">elution_peak_pdf</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
                <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_peak_area_share</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_c_rel_to_peak_max</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_end_i</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_end</span><span class="p">(</span>
                <span class="n">elution_peak_pdf</span>
                <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_c_rel_to_peak_max</span>
                <span class="o">*</span> <span class="n">elution_peak_pdf</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_cv</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_end_i</span> <span class="o">=</span> \
                <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_cv</span>
                    <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_peak_cut_end_i</span> <span class="o">=</span> \
                <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">elution_peak_cut_end_t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Elution peak cut end is not defined.&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; Now collecting to the end of the elution phase.&quot;</span><span class="p">)</span>
            <span class="n">elution_peak_cut_end_i</span> <span class="o">=</span> <span class="n">elution_peak_pdf</span><span class="o">.</span><span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_cut_start_i</span> <span class="o">=</span> <span class="n">elution_peak_cut_start_i</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_cut_end_i</span> <span class="o">=</span> <span class="n">elution_peak_cut_end_i</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;elution_peak_cut_end_i&quot;</span><span class="p">,</span>
                        <span class="n">elution_peak_cut_end_i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;elution_peak_cut_end_t&quot;</span><span class="p">,</span>
                        <span class="n">elution_peak_cut_end_i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_cut_end_i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_t</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Peak end is cut before its maximum.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_cut_end_i</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Peak cut end exceeds elution step duration.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_elution_peak_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calc where the elution peak gets collected.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_mask</span> <span class="o">=</span> \
            <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_cut_end_i</span><span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_mask</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_cut_start_i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;elution_peak_interval&quot;</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_load_btc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update load breakthrough profile.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;CV must be defined by now.&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">update_btc_parameters</span><span class="p">(</span><span class="n">cv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_cv</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calc_regeneration_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calc regeneration step duration.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eq_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_flow_value</span><span class="p">(</span><span class="s2">&quot;Regeneration&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;regeneration_f&quot;</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_f</span><span class="p">,</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_f_rel</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_regeneration_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_time_value</span><span class="p">(</span><span class="s2">&quot;Regeneration&quot;</span><span class="p">,</span>
                                                        <span class="s2">&quot;regeneration_t&quot;</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_t</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="o">.</span><span class="n">regeneration_cv</span><span class="p">,</span>
                                                        <span class="n">eq_f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_regeneration_t</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">regeneration_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;regeneration_t&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regeneration_t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_load_recycle_pdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flow</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update pdf that describes propagation of recycled material.</span>

<span class="sd">        Recycled material si composed of unbound (load) and desorbed</span>
<span class="sd">        (wash) material throughout the column.</span>

<span class="sd">        `self.load_recycle_pdf` gets updated.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;`load_recycle_pdf` must be defined by now.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_porosity_retentate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Retentate porosity must be defined by now.&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;CV must be defined by now.&quot;</span>
        <span class="n">v_void</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">column_porosity_retentate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span><span class="o">.</span><span class="n">update_pdf</span><span class="p">(</span><span class="n">v_void</span><span class="o">=</span><span class="n">v_void</span><span class="p">,</span>
                                         <span class="n">f</span><span class="o">=</span><span class="n">flow</span><span class="p">,</span>
                                         <span class="n">rt_mean</span><span class="o">=</span><span class="n">v_void</span> <span class="o">/</span> <span class="n">flow</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_p_load_recycle_pdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span><span class="o">.</span><span class="n">get_p</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_calc_load_recycle_wash_i</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate wash recycle duration in form of time steps.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle_duration_t</span> <span class="o">&gt;</span> <span class="mi">0</span> \
                <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle_duration_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_time_value</span><span class="p">(</span>
                <span class="s2">&quot;Wash recycle&quot;</span><span class="p">,</span> <span class="s2">&quot;load_wash_recycle_t&quot;</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle_duration_t</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle_duration_cv</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span>
            <span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Same as wash duration.</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_load_bt_cycle_switch_criteria</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                           <span class="n">load_c_ss</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                                           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get steady-state cycle switch (== end of load) criteria.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        load_c_ss</span>
<span class="sd">            Load concentration during steady state operation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Threshold concentration for load breakthrough.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_ss</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_relative_ss</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Load step duration should be defined!&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_ss</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">load_c_end_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_ss</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_relative_ss</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cycle time defined by `load_c_end_ss`&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; and `load_c_end_relative_ss`.&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; Simulation is using `load_c_end_ss`.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># self.load_c_end_relative_ss &gt; 0</span>
            <span class="n">load_c_end_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_relative_ss</span> <span class="o">*</span> <span class="n">load_c_ss</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s1">&#39;load_c_end_ss&#39;</span><span class="p">,</span>
                        <span class="n">load_c_end_ss</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">load_c_end_ss</span>

    <span class="c1"># noinspection DuplicatedCode</span>
    <span class="k">def</span> <span class="nf">_calc_cycle_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates cycle time (== load time for a single column).</span>

<span class="sd">        Optional delay of first cycle is not part of this calculation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">t_cycle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cv</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_ss</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                    <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_relative_ss</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cycle time defined in more than one way.&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; Simulation is using `load_cv`.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Get bt profile for constant inlet.</span>
            <span class="c1"># Inlet conc.</span>
            <span class="n">binding_species</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">]</span>
            <span class="n">load_c_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_steady_state_mean_c</span><span class="p">(</span><span class="n">binding_species</span><span class="p">)</span>
            <span class="c1"># Simulate first cycle at constant load concentration.</span>
            <span class="n">f_first_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">c_first_load</span> <span class="o">=</span> <span class="n">load_c_ss</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">binding_species</span><span class="p">),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
            <span class="n">bt_first_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> \
                <span class="n">load_c_ss</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">calc_c_bound</span><span class="p">(</span><span class="n">f_first_load</span><span class="p">,</span>
                                                      <span class="n">c_first_load</span><span class="p">)</span>
            <span class="c1"># Propagate breakthrough.</span>
            <span class="n">bt_first_load_out</span><span class="p">,</span> <span class="n">bt_first_wash_out</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_recycle_propagation</span><span class="p">(</span><span class="n">f_first_load</span><span class="p">,</span>
                                                <span class="n">bt_first_load</span><span class="p">,</span>
                                                <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># Calc cycle duration.</span>
            <span class="n">load_c_end_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_load_bt_cycle_switch_criteria</span><span class="p">(</span><span class="n">load_c_ss</span><span class="p">)</span>
            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">i_t_first_cycle</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                <span class="n">bt_first_load_out</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">load_c_end_ss</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">t_cycle</span> <span class="o">=</span> <span class="n">i_t_first_cycle</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
            <span class="c1"># Wash desorption.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                <span class="n">c_wash_desorbed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_wash_desorption</span><span class="p">(</span>
                    <span class="n">f_first_load</span><span class="p">[:</span><span class="n">i_t_first_cycle</span><span class="p">],</span>
                    <span class="n">c_first_load</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_t_first_cycle</span><span class="p">]</span>
                    <span class="o">-</span> <span class="n">bt_first_load</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_t_first_cycle</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_wash_desorbed</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">bt_first_load_out</span><span class="p">,</span> <span class="n">bt_first_wash_out</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_recycle_propagation</span><span class="p">(</span>
                    <span class="n">f_first_load</span><span class="p">[:</span><span class="n">i_t_first_cycle</span><span class="p">],</span>
                    <span class="n">bt_first_load</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_t_first_cycle</span><span class="p">],</span>
                    <span class="n">c_wash_desorbed</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iterative_solver</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimating cycle duration:&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; Assuming sharp breakthrough profile.&quot;</span><span class="p">)</span>
                <span class="n">i_load_recycle_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span> \
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">m_load_recycle</span> <span class="o">=</span> \
                    <span class="n">bt_first_load_out</span><span class="p">[</span>
                        <span class="p">:,</span>
                        <span class="n">i_load_recycle_start</span><span class="p">:</span><span class="n">i_t_first_cycle</span>
                    <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
                <span class="n">_t_diff</span> <span class="o">=</span> <span class="n">m_load_recycle</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">/</span> <span class="n">load_c_ss</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">t_cycle</span> <span class="o">-=</span> <span class="n">_t_diff</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_load_recycle_m_ss</span> <span class="o">=</span> <span class="n">m_load_recycle</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                <span class="s1">&#39;m_load_recycle_ss&#39;</span><span class="p">,</span>
                                <span class="n">m_load_recycle</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                <span class="s1">&#39;shorten_cycle_t_due_to_bt_recycle&#39;</span><span class="p">,</span>
                                <span class="n">_t_diff</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iterative_solver</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimating cycle duration:&quot;</span>
                               <span class="sa">f</span><span class="s2">&quot; Assuming sharp breakthrough profile.&quot;</span><span class="p">)</span>
                <span class="n">m_wash_recycle</span> <span class="o">=</span> <span class="n">bt_first_wash_out</span><span class="p">[</span>
                                     <span class="p">:,</span>
                                     <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span>
                                 <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
                <span class="n">_t_diff</span> <span class="o">=</span> <span class="n">m_wash_recycle</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">/</span> <span class="n">load_c_ss</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">t_cycle</span> <span class="o">-=</span> <span class="n">_t_diff</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_m_ss</span> <span class="o">=</span> <span class="n">m_wash_recycle</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                <span class="s1">&#39;m_wash_recycle_ss&#39;</span><span class="p">,</span>
                                <span class="n">m_wash_recycle</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                <span class="s1">&#39;shorten_cycle_t_due_to_wash_recycle&#39;</span><span class="p">,</span>
                                <span class="n">_t_diff</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iterative_solver</span> \
                    <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">):</span>
                <span class="n">c_load_fist_cycle</span> <span class="o">=</span> <span class="n">load_c_ss</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">binding_species</span><span class="p">),</span>
                                                          <span class="n">i_t_first_cycle</span> <span class="o">*</span> <span class="mi">2</span><span class="p">])</span>

                <span class="k">def</span> <span class="nf">sim_cycle</span><span class="p">(</span><span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                              <span class="n">c_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                              <span class="n">i_prev_cycle</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                  <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                                  <span class="nb">int</span><span class="p">]:</span>
                    <span class="sd">&quot;&quot;&quot;Simulates load-wash cycle. Calc load duration.</span>

<span class="sd">                    Load duration is determined based on breakthrough</span>
<span class="sd">                    criteria.</span>

<span class="sd">                    Parameters</span>
<span class="sd">                    ----------</span>
<span class="sd">                    f_load</span>
<span class="sd">                        Load flow rate profile.</span>
<span class="sd">                    c_load</span>
<span class="sd">                        Load conc profile.</span>
<span class="sd">                    i_prev_cycle</span>
<span class="sd">                        Previous cycle duration in time steps.</span>

<span class="sd">                    Returns</span>
<span class="sd">                    -------</span>
<span class="sd">                    f_load_next_cycle</span>
<span class="sd">                        Load and wash breakthrough flow rate profile.</span>
<span class="sd">                    c_load_next_cycle</span>
<span class="sd">                        Load and wash breakthrough conc profile.</span>
<span class="sd">                    i_cycle</span>
<span class="sd">                        Current cycle duration in time steps.</span>

<span class="sd">                    &quot;&quot;&quot;</span>
                    <span class="c1"># Load.</span>
                    <span class="n">bt_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> \
                        <span class="n">c_load</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">calc_c_bound</span><span class="p">(</span><span class="n">f_load</span><span class="p">,</span> <span class="n">c_load</span><span class="p">)</span>
                    <span class="c1"># Propagate breakthrough.</span>
                    <span class="n">bt_load_out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_recycle_propagation</span><span class="p">(</span>
                        <span class="n">f_load</span><span class="p">,</span>
                        <span class="n">bt_load</span><span class="p">,</span>
                        <span class="kc">None</span><span class="p">)</span>
                    <span class="c1"># &#39;Stop&#39; load at specified breakthrough criteria.</span>
                    <span class="c1"># noinspection PyTypeChecker</span>
                    <span class="n">i_cycle_duration</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                        <span class="n">bt_load_out</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">load_c_end_ss</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
                    <span class="c1"># Cut load at specified time.</span>
                    <span class="n">bt_load</span> <span class="o">=</span> <span class="n">bt_load</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_cycle_duration</span><span class="p">]</span>
                    <span class="c1"># Wash desorption.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                        <span class="n">c_first_wash_desorbed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_wash_desorption</span><span class="p">(</span>
                            <span class="n">f_load</span><span class="p">[:</span><span class="n">i_cycle_duration</span><span class="p">],</span>
                            <span class="n">c_load</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_cycle_duration</span><span class="p">]</span>
                            <span class="o">-</span> <span class="n">bt_load</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_cycle_duration</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">c_first_wash_desorbed</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="c1"># Propagate load and wash leftovers.</span>
                    <span class="n">bt_load_out</span><span class="p">,</span> <span class="n">bt_wash_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_recycle_propagation</span><span class="p">(</span>
                        <span class="n">f_load</span><span class="p">[:</span><span class="n">i_cycle_duration</span><span class="p">],</span>
                        <span class="n">bt_load</span><span class="p">,</span>
                        <span class="n">c_first_wash_desorbed</span><span class="p">)</span>
                    <span class="c1"># Construct load for next cycle.</span>
                    <span class="c1"># Recycle load.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span>
                        <span class="n">rec_load</span> <span class="o">=</span> <span class="n">bt_load_out</span><span class="p">[:,</span>
                                               <span class="n">i_prev_cycle</span><span class="p">:</span><span class="n">i_cycle_duration</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rec_load</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span>
                            <span class="n">bt_load_out</span><span class="p">[:,</span> <span class="n">i_prev_cycle</span><span class="p">:</span><span class="n">i_cycle_duration</span><span class="p">])</span>
                    <span class="c1"># Next load profiles.</span>
                    <span class="n">c_next_load</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">rec_load</span><span class="p">,</span>
                                                   <span class="n">c_load_fist_cycle</span><span class="p">),</span>
                                                  <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">f_next_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c_next_load</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">wash_recycle_i_duration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span> \
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="c1"># Log.</span>
                    <span class="n">m_load_recycle_ss</span> <span class="o">=</span> \
                        <span class="n">bt_first_load_out</span><span class="p">[</span>
                            <span class="p">:,</span>
                            <span class="n">wash_recycle_i_duration</span><span class="p">:</span><span class="n">i_t_first_cycle</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_recycle_m_ss</span> <span class="o">=</span> <span class="n">m_load_recycle_ss</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                    <span class="s1">&#39;m_load_recycle_ss&#39;</span><span class="p">,</span>
                                    <span class="n">m_load_recycle_ss</span><span class="p">)</span>
                    <span class="c1"># Recycle wash.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                        <span class="n">c_next_load</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="n">bt_wash_out</span><span class="p">[:,</span> <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span><span class="p">]</span>
                        <span class="n">f_next_load</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span><span class="p">]</span> <span class="o">=</span> \
                            <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span>
                        <span class="n">m_wash_recycle_ss</span> <span class="o">=</span> \
                            <span class="n">bt_wash_out</span><span class="p">[:,</span>
                                        <span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span>
                                        <span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_m_ss</span> <span class="o">=</span> <span class="n">m_wash_recycle_ss</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                        <span class="s1">&#39;m_wash_recycle_ss&#39;</span><span class="p">,</span>
                                        <span class="n">m_wash_recycle_ss</span><span class="p">)</span>
                    <span class="c1"># Return next load and cycle duration.</span>
                    <span class="k">return</span> <span class="n">f_next_load</span><span class="p">,</span> <span class="n">c_next_load</span><span class="p">,</span> \
                        <span class="n">i_cycle_duration</span> <span class="o">-</span> <span class="n">i_prev_cycle</span>

                <span class="n">f_load_cycle</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">c_load_fist_cycle</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">c_load_cycle</span> <span class="o">=</span> <span class="n">c_load_fist_cycle</span>
                <span class="n">i_t_cycle_prev</span> <span class="o">=</span> <span class="n">i_t_first_cycle</span>
                <span class="n">i_t_cycle_estimate</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Loop until cycle duration converges.</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iter_solver_max_iter</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i_t_cycle_prev</span> <span class="o">-</span> <span class="n">i_t_cycle_estimate</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                                        <span class="s2">&quot;t_cycle_optimization_loop_iter&quot;</span><span class="p">,</span>
                                        <span class="n">i</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="n">i_t_cycle_prev</span> <span class="o">=</span> <span class="n">i_t_cycle_estimate</span>
                    <span class="n">f_load_cycle</span><span class="p">,</span> <span class="n">c_load_cycle</span><span class="p">,</span> <span class="n">i_t_cycle_estimate</span> <span class="o">=</span> \
                        <span class="n">sim_cycle</span><span class="p">(</span><span class="n">f_load_cycle</span><span class="p">,</span> <span class="n">c_load_cycle</span><span class="p">,</span> <span class="n">i_t_cycle_prev</span><span class="p">)</span>
                    <span class="c1"># print([i, i_t_cycle_prev, i_t_cycle_estimate])</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i_t_cycle_prev</span> <span class="o">-</span> <span class="n">i_t_cycle_estimate</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="s2">&quot;Cycle duration estimator did not converge.&quot;</span><span class="p">)</span>
                <span class="n">t_cycle</span> <span class="o">=</span> <span class="n">i_t_cycle_estimate</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_c_end_estimate_with_iterative_solver</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No need to use iterative solver in case of&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; no recycling of load and/or wash.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_t</span> <span class="o">=</span> <span class="n">t_cycle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s1">&#39;cycle_t&#39;</span><span class="p">,</span> <span class="n">t_cycle</span><span class="p">)</span>

    <span class="c1"># noinspection DuplicatedCode</span>
    <span class="k">def</span> <span class="nf">_calc_first_cycle_extension_t</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calc extension of first load.</span>

<span class="sd">        First load step might be extended for processes with load and/or</span>
<span class="sd">        wash recycle in order to get faster into steady-state regime.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimation of first cycle extension requested&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; on a process without load recycle.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimation of first cycle extension requested&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; on a process without extended first cycle.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle_t</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle_cv</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;CV should be defined by now.&quot;</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Load flow rate should be defined by now.&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle_cv</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_cv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Estimation of first cycle extension is only supported&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; if the cycle length is defined by breakthrough cutoff&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; criteria. This is due to the fact that if all the&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; breakthrough material gets recycles,&quot;</span>
                <span class="sa">f</span><span class="s2">&quot; there is no single steady-state.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">binding_species</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">)</span>
                               <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">]</span>
            <span class="n">load_c_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_estimate_steady_state_mean_c</span><span class="p">(</span><span class="n">binding_species</span><span class="p">)</span>
            <span class="c1">#  simulate first cycle at constant load concentration</span>
            <span class="n">f_first_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">c_first_load</span> <span class="o">=</span> <span class="n">load_c_ss</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">binding_species</span><span class="p">),</span>
                                                 <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">])</span>
            <span class="n">bt_first_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> \
                <span class="n">load_c_ss</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">calc_c_bound</span><span class="p">(</span><span class="n">f_first_load</span><span class="p">,</span>
                                                      <span class="n">c_first_load</span><span class="p">)</span>

            <span class="c1"># propagate breakthrough</span>
            <span class="n">bt_first_load_out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_recycle_propagation</span><span class="p">(</span><span class="n">f_first_load</span><span class="p">,</span>
                                                <span class="n">bt_first_load</span><span class="p">,</span>
                                                <span class="kc">None</span><span class="p">)</span>
            <span class="n">load_c_end_ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_load_bt_cycle_switch_criteria</span><span class="p">(</span><span class="n">load_c_ss</span><span class="p">)</span>
            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">i_t_first_cycle</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span>
                <span class="n">bt_first_load_out</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">load_c_end_ss</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_load_recycle_m_ss&quot;</span><span class="p">),</span> \
                    <span class="sa">f</span><span class="s2">&quot;Function `_calc_cycle_t()` should already be called.&quot;</span>
                <span class="n">dm</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_recycle_m_ss</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_wash_recycle_m_ss&quot;</span><span class="p">),</span> \
                    <span class="sa">f</span><span class="s2">&quot;Function `_calc_cycle_t()` should already be called.&quot;</span>
                <span class="n">dm</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_m_ss</span>
            <span class="n">di</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">dm</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">m_ext_bt</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span>
                    <span class="n">bt_first_load_out</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)[</span><span class="n">i_t_first_cycle</span><span class="p">:]</span>
                <span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
                <span class="n">di</span> <span class="o">+=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start</span><span class="p">(</span><span class="n">m_ext_bt</span> <span class="o">&gt;=</span> <span class="n">dm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">=</span> <span class="n">di</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>

    <span class="k">def</span> <span class="nf">_calc_cycle_start_i_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate load switch positions in form of time steps.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Cycle length must have been determined&quot;</span> \
            <span class="sa">f</span><span class="s2">&quot; (by `_calc_cycle_t()`) by now&quot;</span>
        <span class="n">flow_i_start</span><span class="p">,</span> <span class="n">flow_i_end</span> <span class="o">=</span> \
            <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start_and_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> \
                <span class="sa">f</span><span class="s2">&quot;Prolong of first load cycle is set to `True`,&quot;</span> \
                <span class="sa">f</span><span class="s2">&quot; but the length is undefined.&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Prolong of first load cycle is set to `True`,&quot;</span>
                           <span class="sa">f</span><span class="s2">&quot; but the length of the extension is 0.&quot;</span><span class="p">)</span>
            <span class="n">load_extend_first_cycle_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_cycle_extension_t</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                            <span class="s2">&quot;load_extend_first_cycle_t&quot;</span><span class="p">,</span>
                            <span class="n">load_extend_first_cycle_t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">load_extend_first_cycle_t</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cycle_start_t_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">flow_i_start</span><span class="p">]</span> <span class="o">+</span> <span class="n">load_extend_first_cycle_t</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">flow_i_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_t</span>
        <span class="p">)</span>
        <span class="n">cycle_start_t_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[</span><span class="n">flow_i_start</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span>
            <span class="n">cycle_start_t_list</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;cycle_start_t_list&quot;</span><span class="p">,</span>
                        <span class="n">cycle_start_t_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare everything before cycle-by-cycle simulation.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_non_binding_species</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_load_f</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_cv</span><span class="p">()</span>  <span class="c1"># might depend on load_f</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_report_column_dimensions</span><span class="p">()</span>  <span class="c1"># optional</span>
        <span class="c1"># Equilibration.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_equilibration_t</span><span class="p">()</span>
        <span class="c1"># Wash.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_wash_t_and_f</span><span class="p">()</span>
        <span class="c1"># Elution.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_elution_t_and_f</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_elution_peak_t</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_elution_peak_pdf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_elution_peak_cut_i_start_and_i_end</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_elution_peak_mask</span><span class="p">()</span>
        <span class="c1"># Regeneration.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_regeneration_t</span><span class="p">()</span>
        <span class="c1"># Prepare for estimation of cycle length.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_load_btc</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_load_recycle_pdf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_calc_load_recycle_wash_i</span><span class="p">()</span>
        <span class="c1"># Cycle time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_cycle_t</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_extend_first_cycle</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_first_cycle_extension_t</span><span class="p">()</span>
        <span class="c1"># Cycle start positions == column load switch time points.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_cycle_start_i_list</span><span class="p">()</span>
        <span class="c1"># Make sure cycle duration is long enough.</span>
        <span class="n">_t_cycle_except_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_equilibration_t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> \
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_regeneration_t</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_t</span> <span class="o">&lt;</span> <span class="n">_t_cycle_except_load</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">e</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Load step (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_t</span><span class="si">}</span><span class="s2">) should not be shorter&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; than eq_t + wash_t + elution_t + regeneration_t&quot;</span>
                       <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="n">_t_cycle_except_load</span><span class="si">:</span><span class="s2"> .6</span><span class="si">}</span><span class="s2">)!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sim_c_load_binding</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                            <span class="n">c_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Determine what part of load binds.</span>

<span class="sd">        Load in this context might also contain wash and load recycle</span>
<span class="sd">        from previous steps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f_load</span>
<span class="sd">            Load flow rate profile.</span>
<span class="sd">        c_load</span>
<span class="sd">            Load concentration profile.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_bound</span>
<span class="sd">            Conc profile of bound material.</span>
<span class="sd">        c_unbound</span>
<span class="sd">            Conc profile of unbound material = `c_load` - `c_bound`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">f_load</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">c_load</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> \
            <span class="s2">&quot;f_load and c_load must have the same length&quot;</span>
        <span class="k">assert</span> <span class="n">c_load</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">),</span> \
            <span class="s2">&quot;c_load must contain all binding species&quot;</span>
        <span class="n">c_bound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">calc_c_bound</span><span class="p">(</span><span class="n">f_load</span><span class="p">,</span> <span class="n">c_load</span><span class="p">)</span>
        <span class="c1"># Returns bound and unbound part.</span>
        <span class="k">return</span> <span class="n">c_bound</span><span class="p">,</span> <span class="n">c_load</span> <span class="o">-</span> <span class="n">c_bound</span>

    <span class="k">def</span> <span class="nf">_sim_c_wash_desorption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                               <span class="n">c_bound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get conc profile of desorbed material during wash step.</span>

<span class="sd">        The step has no default logic.</span>
<span class="sd">        Thus it raises `NotImplementedError` if called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f_load</span>
<span class="sd">            Flow rate profile during &#39;effective load&#39; step.</span>

<span class="sd">            The step includes wash recycle, load recycle and load step</span>
<span class="sd">            as a column sees it in a single cycle.</span>
<span class="sd">        c_bound</span>
<span class="sd">            Conc profile of captured material.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Conc profile of desorbed material during wash step.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            This method has no default implementation. Thus it being</span>
<span class="sd">            called it will raise the error.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Not implemented in core this class, as there is</span>
        <span class="c1"># no consensus on typical dynamics and the way to describe it.</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Function not implemented in this class&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sim_c_recycle_propagation</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">f_unbound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">c_unbound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
            <span class="n">c_wash_desorbed</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Propagate unbound and desorbed material through the column.</span>

<span class="sd">        Unbound (breakthrough during load) and desorbed (during wash)</span>
<span class="sd">        sections might have a different flow rates as they come from</span>
<span class="sd">        different steps - load and wash.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f_unbound</span>
<span class="sd">            Flow rate profile during &#39;total load&#39; step for a cycle.</span>

<span class="sd">            The step includes wash recycle, load recycle and load step.</span>
<span class="sd">        c_unbound</span>
<span class="sd">            Conc profile of overloaded material during load step</span>
<span class="sd">            (plus previous wash and load recycle).</span>
<span class="sd">        c_wash_desorbed</span>
<span class="sd">            Conc profile of desorbed material during wash step.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_unbound_propagated</span>
<span class="sd">            Propagated conc profile of overloaded material.</span>
<span class="sd">        c_wash_desorbed_propagated</span>
<span class="sd">            Propagated conc profile of desorbed material.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_wash_f&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_wash_t&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">assert</span> <span class="n">c_unbound</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">c_unbound</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">f_unbound</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">c_wash_desorbed</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">c_wash_desorbed</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">),</span>
                <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> \
                <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">))</span>
        <span class="c1"># Combine on volumetric scale.</span>
        <span class="n">v_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="n">f_unbound</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="n">v_wash</span> <span class="o">=</span> <span class="n">v_load</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> \
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span>
        <span class="n">min_flow</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">f_unbound</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span><span class="p">)</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="n">min_flow</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span>
                       <span class="p">(</span><span class="n">v_wash</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">v_wash</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">v_load</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">dv</span><span class="p">,</span>
                       <span class="n">dv</span><span class="p">)</span>
        <span class="n">c_v_combined</span> <span class="o">=</span> <span class="n">_interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
            <span class="n">_np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v_load</span><span class="p">,</span> <span class="n">v_wash</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">_np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">c_unbound</span><span class="p">,</span> <span class="n">c_wash_desorbed</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span>
        <span class="p">)(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">c_v_combined</span><span class="p">[</span><span class="n">c_v_combined</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Simulate traveling of leftover material through the column.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_load_recycle_pdf</span><span class="p">(</span><span class="n">min_flow</span><span class="p">)</span>
        <span class="n">c_v_combined_propagated</span> <span class="o">=</span> <span class="n">_utils</span><span class="o">.</span><span class="n">convolution</span><span class="o">.</span><span class="n">time_conv</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">,</span> <span class="n">c_v_combined</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_p_load_recycle_pdf</span><span class="p">)</span>
        <span class="c1"># Split back on time scale.</span>
        <span class="n">c_combined_propagated</span> <span class="o">=</span> <span class="n">_interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span>
            <span class="n">v</span><span class="p">,</span>
            <span class="n">c_v_combined_propagated</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="o">=</span><span class="s2">&quot;extrapolate&quot;</span>
        <span class="p">)(</span><span class="n">_np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v_load</span><span class="p">,</span> <span class="n">v_wash</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">c_combined_propagated</span><span class="p">[</span><span class="n">c_combined_propagated</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c_unbound_propagated</span> <span class="o">=</span> <span class="n">c_combined_propagated</span><span class="p">[:,</span> <span class="p">:</span><span class="n">v_load</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
        <span class="n">c_wash_desorbed_propagated</span> <span class="o">=</span> <span class="n">c_combined_propagated</span><span class="p">[:,</span> <span class="n">v_load</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">c_unbound_propagated</span><span class="p">,</span> <span class="n">c_wash_desorbed_propagated</span>

    <span class="k">def</span> <span class="nf">_sim_c_elution_desorption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                  <span class="n">m_bound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                                     <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Simulate elution step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m_bound</span>
<span class="sd">            Vector with amount of product being bound to the column.</span>

<span class="sd">            `m_bound.size == n_species`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_elution</span>
<span class="sd">            Outlet concentration profile during the elution.</span>
<span class="sd">        b_elution_peak</span>
<span class="sd">            Boolean vector. Peak is collected where the value is `True`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="n">i_elution_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">))</span>
        <span class="c1"># Multiply elution peak with the amount of captured product.</span>
        <span class="n">c_elution</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_p_elution_peak</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span><span class="n">i_elution_duration</span><span class="p">]</span> <span class="o">*</span> \
            <span class="n">m_bound</span><span class="p">[:,</span> <span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span>
        <span class="c1"># Pad with zeros to cover the entire elution step duration.</span>
        <span class="k">if</span> <span class="n">c_elution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i_elution_duration</span><span class="p">:</span>
            <span class="n">c_elution</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">c_elution</span><span class="p">,</span>
                                <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                                 <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i_elution_duration</span> <span class="o">-</span> <span class="n">c_elution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                                <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
        <span class="c1"># Boolean mask - `True` where peak is being collected.</span>
        <span class="n">b_elution_peak</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_peak_mask</span>
        <span class="k">return</span> <span class="n">c_elution</span><span class="p">,</span> <span class="n">b_elution_peak</span>

    <span class="k">def</span> <span class="nf">_sim_c_elution_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_time_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get elution buffer composition at the outlet of the column.</span>

<span class="sd">        By default the buffer composition is constant throughout the</span>
<span class="sd">        elution step.</span>

<span class="sd">        Feel free to override this function if you want to simulate</span>
<span class="sd">        linear gradient or if the transient phenomena at the beginning</span>
<span class="sd">        of peak cut needs to be considered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n_time_steps</span>
<span class="sd">            Duration of elution step in number of time steps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Buffer concentration profile at the outlet of the column</span>
<span class="sd">            during the elution step.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Elution buffer composition.</span>
        <span class="n">elution_buffer_composition</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">elution_buffer_c</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elution_buffer_c</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">elution_buffer_composition</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> \
            <span class="ow">or</span> <span class="n">elution_buffer_composition</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> \
            <span class="sa">f</span><span class="s2">&quot;Elution buffer composition must be either empty or have&quot;</span> \
            <span class="sa">f</span><span class="s2">&quot; a concentration value for each specie.&quot;</span>
        <span class="k">assert</span> <span class="n">_np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">elution_buffer_composition</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> \
            <span class="s2">&quot;Concentration values in elution buffer must be &gt;= 0&quot;</span>
        <span class="k">if</span> <span class="n">elution_buffer_composition</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">elution_buffer_composition</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;elution_buffer_composition&quot;</span><span class="p">,</span>
                        <span class="n">elution_buffer_composition</span><span class="p">)</span>
        <span class="c1"># Constant profile.</span>
        <span class="n">c_elution_buffer</span> <span class="o">=</span> <span class="n">elution_buffer_composition</span> \
            <span class="o">*</span> <span class="n">_np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[:</span><span class="n">n_time_steps</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">c_elution_buffer</span>

    <span class="c1"># noinspection PyMethodMayBeStatic,PyUnusedLocal</span>
    <span class="k">def</span> <span class="nf">_sim_c_regeneration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">m_bound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Simulate regeneration step.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m_bound</span>
<span class="sd">            Vector with amount of product being bound to the column at</span>
<span class="sd">            the beginning of the regeneration step.</span>

<span class="sd">            `m_bound.size == n_species`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Optional[ndarray]</span>
<span class="sd">            Outlet concentration profile during regeneration step.</span>
<span class="sd">            E.g. regeneration peak.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># No default implementation.</span>
        <span class="n">c_regeneration</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">c_regeneration</span>

    <span class="k">def</span> <span class="nf">_sim_c_out_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                         <span class="n">c_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                            <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
                                            <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                            <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                                            <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Simulates load-wash-elution-regeneration steps.</span>

<span class="sd">        Regeneration is optional.</span>

<span class="sd">        This function can be replaced in case user wants to use some</span>
<span class="sd">        other variation of bind-elution dynamics.</span>

<span class="sd">        Elution peak cut is applied in this function.</span>
<span class="sd">        Elution peak shape must be defined by now.</span>

<span class="sd">        Return profiles that are `None` are considered being zero.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f_load</span>
<span class="sd">            Inlet (recycle + load) flow rate profile for a cycle.</span>

<span class="sd">            The flow rate might be different during wash recycle.</span>
<span class="sd">        c_load</span>
<span class="sd">            Inlet (recycle + load) concentration profile.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        c_load</span>
<span class="sd">            Conc profile at the outlet of the column during load.</span>
<span class="sd">        c_wash</span>
<span class="sd">            Conc profile at the outlet of the column during wash.</span>
<span class="sd">        c_elution</span>
<span class="sd">            Conc profile at the outlet of the column during elution.</span>
<span class="sd">        b_elution</span>
<span class="sd">            Boolean mask for elution step. `True` where peak is being</span>
<span class="sd">            collected.</span>
<span class="sd">        c_regeneration</span>
<span class="sd">            Conc profile at the outlet of the column during</span>
<span class="sd">            regeneration.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># Evaluate binding.</span>
        <span class="n">c_bound</span><span class="p">,</span> <span class="n">c_unbound</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_load_binding</span><span class="p">(</span><span class="n">f_load</span><span class="p">,</span> <span class="n">c_load</span><span class="p">)</span>
        <span class="c1"># Log.</span>
        <span class="n">m_load</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_load</span> <span class="o">*</span> <span class="n">f_load</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="n">m_bound</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_bound</span> <span class="o">*</span> <span class="n">f_load</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                        <span class="s2">&quot;column_utilization&quot;</span><span class="p">,</span>
                        <span class="n">m_bound</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_bt</span><span class="o">.</span><span class="n">get_total_bc</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_load&quot;</span><span class="p">,</span> <span class="n">m_load</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_bound&quot;</span><span class="p">,</span> <span class="n">m_bound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_unbound&quot;</span><span class="p">,</span> <span class="n">m_load</span> <span class="o">-</span> <span class="n">m_bound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;f_load&quot;</span><span class="p">,</span> <span class="n">f_load</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;c_load&quot;</span><span class="p">,</span> <span class="n">c_load</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;c_bound&quot;</span><span class="p">,</span> <span class="n">c_bound</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;c_unbound&quot;</span><span class="p">,</span> <span class="n">c_unbound</span><span class="p">)</span>
        <span class="c1"># Evaluate desorption during wash.</span>
        <span class="n">c_wash_desorbed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption</span><span class="p">:</span>
            <span class="n">c_wash_desorbed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_wash_desorption</span><span class="p">(</span><span class="n">f_load</span><span class="p">,</span> <span class="n">c_bound</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Subtract desorbed material from bound material.</span>
                <span class="n">m_bound</span> <span class="o">-=</span> <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Log.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;m_wash_desorbed&quot;</span><span class="p">,</span>
                            <span class="n">c_wash_desorbed</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;c_wash_desorbed&quot;</span><span class="p">,</span>
                            <span class="n">c_wash_desorbed</span><span class="p">)</span>
        <span class="c1"># Propagate unbound and desorbed material throughout the column.</span>
        <span class="n">c_out_load</span> <span class="o">=</span> <span class="n">c_unbound</span>
        <span class="n">c_out_wash</span> <span class="o">=</span> <span class="n">c_wash_desorbed</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
            <span class="n">c_out_load</span><span class="p">,</span> <span class="n">c_out_wash</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_recycle_propagation</span><span class="p">(</span><span class="n">f_load</span><span class="p">,</span>
                                                <span class="n">c_unbound</span><span class="p">,</span>
                                                <span class="n">c_wash_desorbed</span><span class="p">)</span>
        <span class="c1"># Get elution peak.</span>
        <span class="n">c_out_elution</span><span class="p">,</span> <span class="n">elution_peak_mask</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_elution_desorption</span><span class="p">(</span><span class="n">m_bound</span><span class="p">)</span>
        <span class="c1"># Log.</span>
        <span class="n">m_elution_peak</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_out_elution</span> <span class="o">*</span> <span class="n">elution_peak_mask</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
                          <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="n">m_elution</span> <span class="o">=</span> <span class="n">c_out_elution</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                        <span class="s2">&quot;m_elution_peak&quot;</span><span class="p">,</span> <span class="n">m_elution_peak</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                        <span class="s2">&quot;m_elution&quot;</span><span class="p">,</span> <span class="n">m_elution</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                        <span class="s2">&quot;m_elution_peak_cut_loss&quot;</span><span class="p">,</span> <span class="n">m_elution</span> <span class="o">-</span> <span class="n">m_elution_peak</span><span class="p">)</span>
        <span class="c1"># Get regeneration peak.</span>
        <span class="n">c_out_regeneration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_regeneration</span><span class="p">(</span>
            <span class="n">m_bound</span> <span class="o">-</span> <span class="n">c_out_elution</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">c_out_load</span><span class="p">,</span> <span class="n">c_out_wash</span><span class="p">,</span> <span class="n">c_out_elution</span><span class="p">,</span> \
            <span class="n">elution_peak_mask</span><span class="p">,</span> <span class="n">c_out_regeneration</span>

    <span class="k">def</span> <span class="nf">_calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Pre calculate parameters and repetitive profiles.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_simulation</span><span class="p">()</span>
        <span class="c1"># Assert proper list of binding species.</span>
        <span class="n">binding_species</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span><span class="p">)</span>
                           <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">binding_species</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="c1"># Copy inlet vectors.</span>
        <span class="n">c_in_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[</span><span class="n">binding_species</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">f_in_load</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">f_in_i_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_end</span><span class="p">(</span><span class="n">f_in_load</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">c_in_load</span><span class="p">[:,</span> <span class="n">f_in_i_end</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Clear for results.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Prepare logger.</span>
        <span class="n">log_data_cycles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">set_branch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span> <span class="s2">&quot;cycles&quot;</span><span class="p">,</span> <span class="n">log_data_cycles</span><span class="p">)</span>
        <span class="c1"># Variable to store wash recycle to.</span>
        <span class="n">previous_c_bt_wash</span><span class="p">:</span> <span class="n">_typing</span><span class="o">.</span><span class="n">Optional</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Loop across cycles.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
            <span class="c1"># Load-wash-elution-regeneration-equilibration steps for a column.</span>
            <span class="c1"># Load step starts at `self._cycle_start_i_list[i]`.</span>

            <span class="c1"># Prepare logger for this cycle.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="n">log_data_cycles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">)</span>
            <span class="c1"># Load start and end time as the column sees it.</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span>
                <span class="c1"># Column sees leftovers from previous load during recycling.</span>
                <span class="n">cycle_load_i_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cycle_load_i_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Calc cycle end (either next cycle or end or simulation time).</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">cycle_load_i_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cycle_load_i_end</span> <span class="o">=</span> <span class="n">f_in_i_end</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># Log results.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;i_cycle_load_start&quot;</span><span class="p">,</span>
                            <span class="n">cycle_load_i_start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;i_cycle_load_step_start&quot;</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;i_cycle_load_end&quot;</span><span class="p">,</span>
                            <span class="n">cycle_load_i_end</span><span class="p">)</span>
            <span class="c1"># Calc profiles at column outlet.</span>
            <span class="n">c_out_load</span><span class="p">,</span> <span class="n">c_out_wash</span><span class="p">,</span> <span class="n">c_out_elution</span><span class="p">,</span> \
                <span class="n">b_out_elution</span><span class="p">,</span> <span class="n">c_out_regeneration</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sim_c_out_cycle</span><span class="p">(</span>
                    <span class="n">f_in_load</span><span class="p">[</span><span class="n">cycle_load_i_start</span><span class="p">:</span><span class="n">cycle_load_i_end</span><span class="p">],</span>
                    <span class="n">c_in_load</span><span class="p">[:,</span> <span class="n">cycle_load_i_start</span><span class="p">:</span><span class="n">cycle_load_i_end</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;c_out_load&quot;</span><span class="p">,</span> <span class="n">c_out_load</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;c_out_wash&quot;</span><span class="p">,</span> <span class="n">c_out_wash</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;c_out_elution&quot;</span><span class="p">,</span> <span class="n">c_out_elution</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;b_out_elution&quot;</span><span class="p">,</span> <span class="n">b_out_elution</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                            <span class="s2">&quot;c_out_regeneration&quot;</span><span class="p">,</span> <span class="n">c_out_regeneration</span><span class="p">)</span>
            <span class="c1"># Load recycle.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span><span class="p">:</span>
                <span class="c1"># Recycle load during the load step.</span>
                <span class="n">i_load_start_rel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> \
                                   <span class="o">-</span> <span class="n">cycle_load_i_start</span>
                <span class="n">c_load_recycle</span> <span class="o">=</span> <span class="n">c_out_load</span><span class="p">[:,</span> <span class="n">i_load_start_rel</span><span class="p">:]</span>
                <span class="n">c_in_load</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">cycle_load_i_end</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">c_load_recycle</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_load_recycle&quot;</span><span class="p">,</span>
                                <span class="n">c_load_recycle</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;c_load_recycle&quot;</span><span class="p">,</span>
                                <span class="n">c_load_recycle</span><span class="p">)</span>
                <span class="c1"># Losses during load == bt through 2nd column.</span>
                <span class="n">c_loss_bt_2nd_column</span> <span class="o">=</span> <span class="n">c_out_load</span><span class="p">[:,</span> <span class="n">i_load_start_rel</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_loss_bt_2nd_column&quot;</span><span class="p">,</span>
                                <span class="n">c_loss_bt_2nd_column</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                                <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;c_loss_bt_2nd_column&quot;</span><span class="p">,</span>
                                <span class="n">c_loss_bt_2nd_column</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># report losses during load</span>
                <span class="n">m_loss_load</span> <span class="o">=</span> <span class="n">c_out_load</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_loss_load&quot;</span><span class="p">,</span> <span class="n">m_loss_load</span><span class="p">)</span>
            <span class="c1"># Wash recycle.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">previous_c_bt_wash</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                        <span class="ow">and</span> <span class="n">previous_c_bt_wash</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Clip wash recycle duration if needed.</span>
                    <span class="n">i_wash_duration</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_wash_recycle_i_duration</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="c1"># Log losses due to discarding load bt during wash recycle.</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">c_in_load</span><span class="p">[</span>
                        <span class="p">:,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="o">+</span> <span class="n">i_wash_duration</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                                    <span class="s2">&quot;m_loss_load_bt_during_wash_recycle&quot;</span><span class="p">,</span>
                                    <span class="n">s</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span>
                                    <span class="s2">&quot;c_lost_load_during_wash_recycle&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;c_wash_recycle&quot;</span><span class="p">,</span>
                                    <span class="n">previous_c_bt_wash</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_wash_duration</span><span class="p">])</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_wash_recycle&quot;</span><span class="p">,</span>
                        <span class="n">previous_c_bt_wash</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_wash_duration</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span><span class="p">)</span>
                    <span class="c1"># Apply previous wash recycle onto the inlet profile.</span>
                    <span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">previous_c_bt_wash</span><span class="p">[:,</span> <span class="p">:</span><span class="n">i_wash_duration</span><span class="p">]</span>
                    <span class="n">f_in_load</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">_cycle_start_i_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                              <span class="o">+</span> <span class="n">i_wash_duration</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span>
                <span class="c1"># Save wash from this cycle to be used during the next cycle.</span>
                <span class="n">previous_c_bt_wash</span> <span class="o">=</span> <span class="n">c_out_wash</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Report losses during wash.</span>
                <span class="k">if</span> <span class="n">c_out_wash</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">c_out_wash</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                        <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">binding_species</span><span class="p">),</span>
                         <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">))])</span>
                <span class="n">m_loss_wash</span> <span class="o">=</span> <span class="n">c_out_wash</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;m_loss_wash&quot;</span><span class="p">,</span> <span class="n">m_loss_wash</span><span class="p">)</span>
            <span class="c1"># Elution.</span>
            <span class="p">[</span><span class="n">i_el_rel_start</span><span class="p">,</span> <span class="n">i_el_rel_end</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">_utils</span><span class="o">.</span><span class="n">vectors</span><span class="o">.</span><span class="n">true_start_and_end</span><span class="p">(</span><span class="n">b_out_elution</span><span class="p">)</span>
            <span class="n">i_el_start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">cycle_load_i_end</span> <span class="o">+</span> <span class="n">c_out_wash</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_el_rel_start</span><span class="p">)</span>
            <span class="n">i_el_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
                <span class="n">cycle_load_i_end</span> <span class="o">+</span> <span class="n">c_out_wash</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">i_el_rel_end</span><span class="p">)</span>
            <span class="n">i_el_rel_end</span> <span class="o">=</span> <span class="n">i_el_rel_start</span> <span class="o">+</span> <span class="n">i_el_end</span> <span class="o">-</span> <span class="n">i_el_start</span>
            <span class="c1"># Log.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;i_elution_start&quot;</span><span class="p">,</span> <span class="n">i_el_start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">i_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span><span class="p">,</span> <span class="s2">&quot;i_elution_end&quot;</span><span class="p">,</span> <span class="n">i_el_end</span><span class="p">)</span>
            <span class="c1"># Write to global outlet.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f</span><span class="p">[</span><span class="n">i_el_start</span><span class="p">:</span><span class="n">i_el_end</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elution_f</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_c</span><span class="p">[</span><span class="n">binding_species</span><span class="p">,</span> <span class="n">i_el_start</span><span class="p">:</span><span class="n">i_el_end</span><span class="p">]</span> <span class="o">=</span> \
                <span class="n">c_out_elution</span><span class="p">[:,</span> <span class="n">i_el_rel_start</span><span class="p">:</span><span class="n">i_el_rel_end</span><span class="p">]</span></div>


<div class="viewcode-block" id="ACC"><a class="viewcode-back" href="../../../bio_rtd/uo.sc_uo.html#bio_rtd.uo.sc_uo.ACC">[docs]</a><span class="k">class</span> <span class="nc">ACC</span><span class="p">(</span><span class="n">AlternatingChromatography</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alternating column chromatography without recycling.</span>

<span class="sd">    Alternating load-bind-elution twin-column chromatography without</span>
<span class="sd">    recycling of overloaded or washed out material.</span>

<span class="sd">    This class offers no dynamics for desorption during wash step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">        Starts with 0 and has a constant time step.</span>
<span class="sd">    uo_id</span>
<span class="sd">        Unique identifier.</span>
<span class="sd">    load_bt</span>
<span class="sd">        Load breakthrough logic.</span>
<span class="sd">    peak_shape_pdf</span>
<span class="sd">        Elution peak shape.</span>
<span class="sd">    gui_title</span>
<span class="sd">        Readable title for GUI. Default = &quot;ACC&quot;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For list of attributes refer to :class:`AlternatingChromatography`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`AlternatingChromatography`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    &gt;&gt;&gt; dt = 0.5  # min</span>
<span class="sd">    &gt;&gt;&gt; t = _np.arange(0, 24.1 * 60, dt)</span>
<span class="sd">    &gt;&gt;&gt; load_bt = _bt_load.ConstantPatternSolution(dt, dbc_100=50, k=0.12)</span>
<span class="sd">    &gt;&gt;&gt; peak_shape_pdf = _pdf.ExpModGaussianFixedRelativeWidth(t, 0.15, 0.3)</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a = ACC(</span>
<span class="sd">    ...     t,</span>
<span class="sd">    ...     load_bt=load_bt,</span>
<span class="sd">    ...     peak_shape_pdf=peak_shape_pdf,</span>
<span class="sd">    ...     uo_id=&quot;pro_a_acc&quot;,</span>
<span class="sd">    ...     gui_title=&quot;ProteinA ACC&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.cv = 100  # mL</span>
<span class="sd">    &gt;&gt;&gt; # Equilibration step.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.equilibration_cv = 1.5</span>
<span class="sd">    &gt;&gt;&gt; # Equilibration flow rate is same as load flow rate.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.equilibration_f_rel = 1</span>
<span class="sd">    &gt;&gt;&gt; # Load 10 CVs.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.load_cv = 20</span>
<span class="sd">    &gt;&gt;&gt; # Define wash step.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.wash_cv = 5</span>
<span class="sd">    &gt;&gt;&gt; # Elution step.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.elution_cv = 3</span>
<span class="sd">    &gt;&gt;&gt; # 1st momentum of elution peak from data from above.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.elution_peak_position_cv = 1.2</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.elution_peak_cut_start_c_rel_to_peak_max = 0.05</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.elution_peak_cut_end_c_rel_to_peak_max = 0.05</span>
<span class="sd">    &gt;&gt;&gt; # Regeneration step.</span>
<span class="sd">    &gt;&gt;&gt; acc_pro_a.regeneration_cv = 1.5</span>
<span class="sd">    &gt;&gt;&gt; # Inlet flow rate profile.</span>
<span class="sd">    &gt;&gt;&gt; f_in = _np.ones_like(t) * 15  # mL/min</span>
<span class="sd">    &gt;&gt;&gt; c_in = _np.ones([1, t.size]) * 2.5  # mg/mL</span>
<span class="sd">    &gt;&gt;&gt; # Simulate ACC.</span>
<span class="sd">    &gt;&gt;&gt; f_out, c_out = acc_pro_a.evaluate(f_in, c_in)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">load_bt</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">ChromatographyLoadBreakthrough</span><span class="p">,</span>
                 <span class="n">peak_shape_pdf</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">,</span>
                 <span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ACC&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">uo_id</span><span class="p">,</span> <span class="n">load_bt</span><span class="p">,</span> <span class="n">peak_shape_pdf</span><span class="p">,</span> <span class="n">gui_title</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sim_c_wash_desorption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                               <span class="n">c_bound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Desorbed material during wash step is not supported by ACC.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            Raises exception when function if called.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Function not implemented in this class.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PCC"><a class="viewcode-back" href="../../../bio_rtd/uo.sc_uo.html#bio_rtd.uo.sc_uo.PCC">[docs]</a><span class="k">class</span> <span class="nc">PCC</span><span class="p">(</span><span class="n">AlternatingChromatography</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alternating column chromatography with recycling of load.</span>

<span class="sd">    Alternating load-bind-elution twin-column chromatography with</span>
<span class="sd">    optional recycling of overloaded or washed out material.</span>

<span class="sd">    This class offers no dynamics for desorption during wash step.</span>

<span class="sd">    PCC uses :attr:`load_bt` to determine what parts of the load (and</span>
<span class="sd">    recycled material) bind to the column. The unbound (not captured)</span>
<span class="sd">    part is propagated through the column by :attr:`load_recycle_pdf`.</span>

<span class="sd">    Void volume for :attr:`load_recycle_pdf` is defined as</span>
<span class="sd">    :attr:`column_porosity_retentate` * `column volume`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">        Starts with 0 and has a constant time step.</span>
<span class="sd">    uo_id</span>
<span class="sd">        Unique identifier.</span>
<span class="sd">    load_bt</span>
<span class="sd">        Load breakthrough logic.</span>
<span class="sd">    load_recycle_pdf</span>
<span class="sd">        Propagation of load breakthrough and/or washed out material</span>
<span class="sd">        through the column.</span>
<span class="sd">    column_porosity_retentate</span>
<span class="sd">        Porosity of the column for binding species (protein).</span>
<span class="sd">    peak_shape_pdf</span>
<span class="sd">        Elution peak shape.</span>
<span class="sd">    gui_title</span>
<span class="sd">        Readable title for GUI. Default = &quot;PCC&quot;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For list of additional attributes refer to</span>
<span class="sd">    :class:`AlternatingChromatography`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`AlternatingChromatography`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; dt = 0.5  # min</span>
<span class="sd">    &gt;&gt;&gt; t = _np.arange(0, 24.1 * 60, dt)</span>
<span class="sd">    &gt;&gt;&gt; load_bt = _bt_load.ConstantPatternSolution(dt, dbc_100=50, k=0.12)</span>
<span class="sd">    &gt;&gt;&gt; peak_shape_pdf = _pdf.ExpModGaussianFixedRelativeWidth(t, 0.15, 0.3)</span>
<span class="sd">    &gt;&gt;&gt; load_recycle_pdf = _pdf.GaussianFixedDispersion(t, 2 * 2 / 30)</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a = PCC(</span>
<span class="sd">    ...     t,</span>
<span class="sd">    ...     load_bt=load_bt,</span>
<span class="sd">    ...     peak_shape_pdf=peak_shape_pdf,</span>
<span class="sd">    ...     load_recycle_pdf=load_recycle_pdf,</span>
<span class="sd">    ...     # Porosity of the column for protein.</span>
<span class="sd">    ...     column_porosity_retentate=0.64,</span>
<span class="sd">    ...     uo_id=&quot;pro_a_pcc&quot;,</span>
<span class="sd">    ...     gui_title=&quot;ProteinA PCC&quot;,</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.cv = 100  # mL</span>
<span class="sd">    &gt;&gt;&gt; # Equilibration step.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.equilibration_cv = 1.5</span>
<span class="sd">    &gt;&gt;&gt; # Equilibration flow rate is same as load flow rate.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.equilibration_f_rel = 1</span>
<span class="sd">    &gt;&gt;&gt; # Load until 70 % breakthrough.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.load_c_end_relative_ss = 0.7</span>
<span class="sd">    &gt;&gt;&gt; # Automatically prolong first cycle to faster achieve a steady-state.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.load_extend_first_cycle = True</span>
<span class="sd">    &gt;&gt;&gt; # Define wash step.</span>
<span class="sd">    &gt;&gt;&gt; # There is no desorption during wash step in this example.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.wash_cv = 5</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.wash_recycle = True</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.wash_recycle_duration_cv = 2</span>
<span class="sd">    &gt;&gt;&gt; # Elution step.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.elution_cv = 3</span>
<span class="sd">    &gt;&gt;&gt; # 1st momentum of elution peak from data from above.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.elution_peak_position_cv = 1.2</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.elution_peak_cut_start_c_rel_to_peak_max = 0.05</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.elution_peak_cut_end_c_rel_to_peak_max = 0.05</span>
<span class="sd">    &gt;&gt;&gt; # Regeneration step.</span>
<span class="sd">    &gt;&gt;&gt; pcc_pro_a.regeneration_cv = 1.5</span>
<span class="sd">    &gt;&gt;&gt; # Inlet flow rate profile.</span>
<span class="sd">    &gt;&gt;&gt; f_in = _np.ones_like(t) * 15  # mL/min</span>
<span class="sd">    &gt;&gt;&gt; c_in = _np.ones([1, t.size]) * 2.5  # mg/mL</span>
<span class="sd">    &gt;&gt;&gt; # Simulate ACC.</span>
<span class="sd">    &gt;&gt;&gt; f_out, c_out = pcc_pro_a.evaluate(f_in, c_in) # doctest: +ELLIPSIS</span>
<span class="sd">    pro_a_pcc: Steady-state concentration is being estimated ...</span>
<span class="sd">    pro_a_pcc: Steady-state concentration is being estimated ...</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">load_bt</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">ChromatographyLoadBreakthrough</span><span class="p">,</span>
                 <span class="n">load_recycle_pdf</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">,</span>
                 <span class="n">column_porosity_retentate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">peak_shape_pdf</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">,</span>
                 <span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;PCC&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">uo_id</span><span class="p">,</span> <span class="n">load_bt</span><span class="p">,</span> <span class="n">peak_shape_pdf</span><span class="p">,</span> <span class="n">gui_title</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Recycle load breakthrough. Default = `True`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="sd">&quot;&quot;&quot;Recycle wash. Default = False.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column_porosity_retentate</span> <span class="o">=</span> <span class="n">column_porosity_retentate</span>
        <span class="sd">&quot;&quot;&quot;Column porosity for binding species.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`PCC`</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        `column_porosity_retentate` is a mean residence time of the</span>
<span class="sd">        product (protein) traveling through the column during</span>
<span class="sd">        non-binding conditions (in CVs).</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle_pdf</span> <span class="o">=</span> <span class="n">load_recycle_pdf</span>
        <span class="sd">&quot;&quot;&quot;PDF of wash and/or unbound load traveling through the column.</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :class:`PCC`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_sim_c_wash_desorption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                               <span class="n">c_bound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Desorbed material during wash step is not supported by PCC.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            Raises exception when function if called.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Function not implemented in this class.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="PCCWithWashDesorption"><a class="viewcode-back" href="../../../bio_rtd/uo.sc_uo.html#bio_rtd.uo.sc_uo.PCCWithWashDesorption">[docs]</a><span class="k">class</span> <span class="nc">PCCWithWashDesorption</span><span class="p">(</span><span class="n">PCC</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Alternating column chromatography with recycling of load.</span>

<span class="sd">    Alternating load-bind-elution twin-column chromatography with</span>
<span class="sd">    optional recycling of overloaded or washed out material.</span>

<span class="sd">    The material desorption during wash step is defined by exponential</span>
<span class="sd">    half life time</span>

<span class="sd">    * :attr:`wash_desorption_tail_half_time_cv`</span>

<span class="sd">    and the amount of desorbable material which is defined by</span>

<span class="sd">    * :attr:`wash_desorption_desorbable_material_share` or</span>
<span class="sd">    * :attr:`wash_desorption_desorbable_above_dbc`.</span>

<span class="sd">    PCC uses :attr:`load_bt` to determine what parts of the load (and</span>
<span class="sd">    recycled material) bind to the column.</span>

<span class="sd">    The unbound (not captured) part and desorbed part are propagated</span>
<span class="sd">    through the column by :attr:`load_recycle_pdf`.</span>

<span class="sd">    Void volume for :attr:`load_recycle_pdf` is defined as</span>
<span class="sd">    :attr:`column_porosity_retentate` * `column volume`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t</span>
<span class="sd">        Simulation time vector.</span>
<span class="sd">        Starts with 0 and has a constant time step.</span>
<span class="sd">    uo_id</span>
<span class="sd">        Unique identifier.</span>
<span class="sd">    load_bt</span>
<span class="sd">        Load breakthrough logic.</span>
<span class="sd">    load_recycle_pdf</span>
<span class="sd">        Propagation of load breakthrough and/or washed out material</span>
<span class="sd">        through the column.</span>
<span class="sd">    column_porosity_retentate</span>
<span class="sd">        Porosity of the column for binding species (protein).</span>
<span class="sd">    peak_shape_pdf</span>
<span class="sd">        Elution peak shape.</span>
<span class="sd">    gui_title</span>
<span class="sd">        Readable title for GUI. Default = &quot;PCCWithWashDesorption&quot;.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    During wash step, weaker binding isoforms might be desorbed and</span>
<span class="sd">    recycled. In turn they are again desorbed and recycled during next</span>
<span class="sd">    cycle and so on; resulting in increasing amount of desorbed material</span>
<span class="sd">    during wash step (even in steady-state). This is not considered by</span>
<span class="sd">    this class. Furthermore, it is not a favorable case in terms of RTD</span>
<span class="sd">    as the weakly bound material propagates from column to column for</span>
<span class="sd">    many cycles.</span>

<span class="sd">    For list of additional attributes refer to</span>
<span class="sd">    :class:`PCC` and :class:`AlternatingChromatography`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`PCC`</span>
<span class="sd">    :class:`AlternatingChromatography`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">t</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">uo_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">load_bt</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">ChromatographyLoadBreakthrough</span><span class="p">,</span>
                 <span class="n">load_recycle_pdf</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">,</span>
                 <span class="n">column_porosity_retentate</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">peak_shape_pdf</span><span class="p">:</span> <span class="n">_core</span><span class="o">.</span><span class="n">PDF</span><span class="p">,</span>
                 <span class="n">gui_title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;PCCWithWashDesorption&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">uo_id</span><span class="p">,</span> <span class="n">load_bt</span><span class="p">,</span> <span class="n">load_recycle_pdf</span><span class="p">,</span>
                         <span class="n">column_porosity_retentate</span><span class="p">,</span> <span class="n">peak_shape_pdf</span><span class="p">,</span> <span class="n">gui_title</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">load_recycle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Recycle load breakthrough. Default = `True`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_recycle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Recycle wash. Default = `True`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="sd">&quot;&quot;&quot;Simulate desorption during wash step. Default = `True`.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_tail_half_time_cv</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Wash desorption rate.</span>
<span class="sd">        </span>
<span class="sd">        Required if :attr:`wash_desorption` is `True`.</span>
<span class="sd">        </span>
<span class="sd">        Wash desorption is simulated as exponential decay with half-life</span>
<span class="sd">        :attr:`wash_desorption_tail_half_time_cv`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_material_share</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Share of material that can be desorbed during wash step.</span>
<span class="sd">        </span>
<span class="sd">        Wash desorption is simulated as exponential decay. Only part of</span>
<span class="sd">        adsorbed material is subjected to that exponential decay. That</span>
<span class="sd">        part can be defined by:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`wash_desorption_desorbable_material_share` (this one)</span>
<span class="sd">          or</span>
<span class="sd">        * :attr:`wash_desorption_desorbable_above_dbc`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_above_dbc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="sd">&quot;&quot;&quot;Share of material that can be desorbed during wash step.</span>
<span class="sd">        </span>
<span class="sd">        Share is defined as a share of material loaded onto the column</span>
<span class="sd">        that exceeds specified `wash_desorption_desorbable_above_dbc`</span>
<span class="sd">        binding capacity.</span>
<span class="sd">        </span>
<span class="sd">        Wash desorption is simulated as exponential decay. Only part of</span>
<span class="sd">        adsorbed material is subjected to that exponential decay. That</span>
<span class="sd">        part can be defined by:</span>
<span class="sd">        </span>
<span class="sd">        * :attr:`wash_desorption_desorbable_material_share` (this one)</span>
<span class="sd">          or</span>
<span class="sd">        * :attr:`wash_desorption_desorbable_above_dbc`.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_sim_c_wash_desorption</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">f_load</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                               <span class="n">c_bound</span><span class="p">:</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get conc profile of desorbed material during wash step.</span>

<span class="sd">        `self.wash_desorption_tail_half_time_cv` needs to be defined.</span>

<span class="sd">        One of `self.wash_desorption_desorbable_material_share` and</span>
<span class="sd">        `self.wash_desorption_desorbable_above_dbc` needs to be defined.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f_load</span>
<span class="sd">            Flow rate profile during &#39;effective load&#39; step.</span>

<span class="sd">            The step includes wash recycle, load recycle and load step</span>
<span class="sd">            as a column sees it in a single cycle.</span>
<span class="sd">        c_bound</span>
<span class="sd">            Conc profile of captured material.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            Conc profile of desorbed material during wash step.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_tail_half_time_cv</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_material_share</span> <span class="o">&gt;</span> <span class="mi">0</span> \
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_above_dbc</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">assert</span> <span class="n">f_load</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">c_bound</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">assert</span> <span class="n">c_bound</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> \
            <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n_species</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">non_binding_species</span><span class="p">)</span>
        <span class="n">m_bound</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_bound</span> <span class="o">*</span> <span class="n">f_load</span><span class="p">[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)[:,</span> <span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> \
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
        <span class="c1"># Calc share of desorbable material.</span>
        <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_material_share</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_material_share</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_above_dbc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">w</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Share of desorbable material defined twice!!&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; Using `load_recycle_wash_desorbable_material_share`&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                        <span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_desorbable_above_dbc</span>
                        <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="n">m_bound</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">assert</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Share of desorbable material </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span> \
                            <span class="sa">f</span><span class="s2">&quot; must be &gt;= 0 and &lt;= 1.&quot;</span>
        <span class="n">i_wash_duration</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_wash_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span><span class="p">))</span>
        <span class="c1"># Generate exponential tail.</span>
        <span class="n">exp_pdf</span> <span class="o">=</span> <span class="n">_pdf</span><span class="o">.</span><span class="n">TanksInSeries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">[:</span><span class="n">i_wash_duration</span><span class="p">],</span>
                                     <span class="n">n_tanks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                     <span class="n">pdf_id</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;wash_desorption_exp_drop&quot;</span><span class="p">)</span>
        <span class="n">exp_pdf</span><span class="o">.</span><span class="n">allow_open_end</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">exp_pdf</span><span class="o">.</span><span class="n">trim_and_normalize</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tau</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wash_desorption_tail_half_time_cv</span> \
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cv</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span> <span class="o">/</span> <span class="n">_np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">exp_pdf</span><span class="o">.</span><span class="n">update_pdf</span><span class="p">(</span><span class="n">rt_mean</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">exp_pdf</span><span class="o">.</span><span class="n">get_p</span><span class="p">()[</span><span class="n">_np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:</span><span class="n">i_wash_duration</span><span class="p">]</span>
        <span class="c1"># Scale desorbed material conc due to differences in flow rate.</span>
        <span class="n">c_desorbed</span> <span class="o">=</span> <span class="n">m_bound</span> <span class="o">*</span> <span class="n">k</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wash_f</span>
        <span class="c1"># Pad with zeros if needed.</span>
        <span class="n">c_desorbed</span> <span class="o">=</span> <span class="n">_np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">c_desorbed</span><span class="p">,</span>
                             <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                              <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i_wash_duration</span> <span class="o">-</span> <span class="n">c_desorbed</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span>
                             <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">)</span>
        <span class="c1"># Log.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">d_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cycle_tree</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_cycle_tree&quot;</span><span class="p">)</span>
                        <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_log_tree</span><span class="p">,</span>
                        <span class="s2">&quot;p_desorbed&quot;</span><span class="p">,</span>
                        <span class="n">p</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">c_desorbed</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, University of Natural Resources and Life Sciences (BOKU), Vienna

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>